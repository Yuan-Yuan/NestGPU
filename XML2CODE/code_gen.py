#! /usr/bin/python
"""
   Copyright (c) 2012-2013 The Ohio State University.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

"""
Some assumptions:
    1. the supported query is SSBM query
    2. the fact table is the left child of the the join node and the dimension table is the right table
    3. the size of the dimension table is small enough to be fit into GPU memory.
    4. currently each thread will try to allocate its needed gpu memory before executing.
       if it fails, it can wait until it gets the memory. There may be deadlocks here.
    5. the current relation supported in where list is only AND, OR
    6. the data to be grouped by and ordered by are small enough to be fit into gpu memory
    7. dimension tables are not compressed.
"""

import sys
import commands
import os.path
import copy
import ystree
import correlation
import config
import pickle

schema = None
keepInGpu = 1 
baseIndent = " " * 4

"""
Get the value of the configurable variables from config.py
"""

joinType = config.joinType 
POS = config.POS
SOA = config.SOA
CODETYPE = config.CODETYPE

PID = config.PID
DTYPE = config.DTYPE

"""
Generate C style declaration of a given column.
The name of the variable is the lower cased column name.
"""

def column_to_variable(col):
    res = ""
    if col.column_type in ["INTEGER","DATE"]:
        res = "int " + col.column_name.lower() + ";"
    elif col.column_type in ["DECIMAL"]:
        res = "float " + col.column_name.lower() + ";"
    elif col.column_type in ["TEXT"]:
        res = "char " + col.column_name.lower() + "[" + str(col.column_others) + "];"

    return res

"""
Generate schema.h file from the defined table schema.
"""

def generate_schema_file():
    global schema

    schema = ystree.global_table_dict
    fo = open("schema.h","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#ifndef __SCHEMA_H__"
    print >>fo, "#define __SCHEMA_H__"
    for tn in schema.keys():
        print >>fo, "\tstruct " + tn.lower() + " {"
        for col in schema[tn].column_list:
            print >>fo, "\t\t" + column_to_variable(col)
        print >>fo, "\t};\n"

    print >>fo, "#endif"
    fo.close()

"""
generate_soa generates a python script that will help transform
data from AOS to SOA. This is only for comparing the performance
of SOA with AOS. 
"""

def generate_soa():

    global schema

    schema = ystree.global_table_dict

    fo = open("soa.py","w")

    print >>fo, "#! /usr/bin/python"
    print >>fo, "import os\n"

    print >>fo, "cmd = \"\""
    for tn in schema.keys():
        attrLen = len(schema[tn].column_list)

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            if col.column_type == "TEXT":
                print >>fo, "cmd = \"./soa " + tn + str(i) + " " + str(col.column_others) + "\""
                print >>fo, "os.system(cmd)"

    fo.close()
    os.system("chmod +x ./soa.py")

"""
generate_loader will generate the load.c which will transform
the row-stored text raw data into column-stored binary data.
"""

def generate_loader():
    global schema

    schema = ystree.global_table_dict

    fo = open("load.c","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#define _FILE_OFFSET_BITS       64"
    print >>fo, "#define _LARGEFILE_SOURCE"
    print >>fo, "#include <stdio.h>"
    print >>fo, "#include <stdlib.h>"
    print >>fo, "#include <error.h>"
    print >>fo, "#include <unistd.h>"
    print >>fo, "#include <string.h>"
    print >>fo, "#include <getopt.h>"
    print >>fo, "#include <linux/limits.h>"
    print >>fo, "#include \"../include/schema.h\""
    print >>fo, "#include \"../include/common.h\""
    print >>fo, "#define CHECK_POINTER(p) do {\\"
    print >>fo, "\tif(p == NULL){   \\"
    print >>fo, "\t\tperror(\"Failed to allocate host memory\");    \\"
    print >>fo, "\t\texit(-1);  \\"
    print >>fo, "\t}} while(0)"

    print >>fo, "static char delimiter = '|';"

    for tn in schema.keys():
        attrLen = len(schema[tn].column_list)

        print >>fo, "void " + tn.lower() + " (FILE *fp, char *outName){\n"

        print >>fo, "\tstruct " + tn.lower() + " tmp;"
        print >>fo, "\tchar data [1024] = {0};"
        print >>fo, "\tchar buf[1024] = {0};"
        print >>fo, "\tint count = 0, i = 0,prev = 0;"
        print >>fo, "\tlong tupleCount =0, tupleRemain = 0, tupleUnit = 0;"
        print >>fo, "\tFILE * out[" + str(attrLen) + "];\n"

        print >>fo, "\tfor(i=0;i<" + str(attrLen) + ";i++){"
        print >>fo, "\t\tchar path[PATH_MAX] = {0};"
        print >>fo, "\t\tsprintf(path,\"%s%d\",outName,i);"
        print >>fo, "\t\tout[i] = fopen(path, \"w\");"
        print >>fo, "\t\tif(!out[i]){"
        print >>fo, "\t\t\tprintf(\"Failed to open %s\\n\",path);"
        print >>fo, "\t\t\texit(-1);"
        print >>fo, "\t\t}"
        print >>fo, "\t}\n"

        print >>fo, "\tstruct columnHeader header;"
        print >>fo, "\tlong tupleNum = 0;"
        print >>fo, "\twhile(fgets(buf,sizeof(buf),fp) !=NULL)"
        print >>fo, "\t\ttupleNum ++;\n"
        print >>fo, "\theader.totalTupleNum = tupleNum;"
        print >>fo, "\ttupleRemain = tupleNum;"

        print >>fo, "\tif(tupleNum > BLOCKNUM)"
        print >>fo, "\t\ttupleUnit = BLOCKNUM;"
        print >>fo, "\telse"
        print >>fo, "\t\ttupleUnit = tupleNum;"

        print >>fo, "\theader.tupleNum = tupleUnit;"
        print >>fo, "\theader.format = UNCOMPRESSED;"
        print >>fo, "\theader.blockId = 0;"
        print >>fo, "\theader.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;"

        print >>fo, "\tfseek(fp,0,SEEK_SET);"

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            if col.column_type == "INTEGER" or col.column_type == "DATE":
                print >>fo, "\theader.blockSize = header.tupleNum * sizeof(int);"
            elif col.column_type == "DECIMAL":
                print >>fo, "\theader.blockSize = header.tupleNum * sizeof(float);"
            elif col.column_type == "TEXT":
                print >>fo, "\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"

            print >>fo, "\tfwrite(&header, sizeof(struct columnHeader), 1, out[" + str(i) + "]);"

        print >>fo, "\twhile(fgets(buf,sizeof(buf),fp)!= NULL){"

        print >>fo, "\t\tint writeHeader = 0;"
        print >>fo, "\t\ttupleCount ++;"
        print >>fo, "\t\tif(tupleCount > BLOCKNUM){"
        print >>fo, "\t\t\ttupleCount = 1;"
        print >>fo, "\t\t\ttupleRemain -= BLOCKNUM;"
        print >>fo, "\t\t\tif (tupleRemain > BLOCKNUM)"
        print >>fo, "\t\t\t\ttupleUnit = BLOCKNUM;"
        print >>fo, "\t\t\telse"
        print >>fo, "\t\t\t\ttupleUnit = tupleRemain;"
        print >>fo, "\t\t\theader.tupleNum = tupleUnit;"
        print >>fo, "\t\t\theader.blockId ++;"
        print >>fo, "\t\t\twriteHeader = 1;"
        print >>fo, "\t\t}"

        print >>fo, "\t\tfor(i = 0, prev = 0,count=0; buf[i] !='\\n';i++){"
        print >>fo, "\t\t\tif (buf[i] == delimiter){"
        print >>fo, "\t\t\t\tmemset(data,0,sizeof(data));"
        print >>fo, "\t\t\t\tstrncpy(data,buf+prev,i-prev);"
        print >>fo, "\t\t\t\tprev = i+1;"
        print >>fo, "\t\t\t\tswitch(count){"

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            print >>fo, "\t\t\t\t\t case " + str(i) + ":"

            if col.column_type == "INTEGER" or col.column_type == "DATE":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * sizeof(int);"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\ttmp."+str(col.column_name.lower()) + " = strtol(data,NULL,10);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(int),1,out["+str(i) + "]);"
            elif col.column_type == "DECIMAL":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * sizeof(float);"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\ttmp."+str(col.column_name.lower()) + " = atof(data);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(float),1,out["+str(i) + "]);"
            elif col.column_type == "TEXT":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\tstrcpy(tmp." + str(col.column_name.lower()) + ",data);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(tmp." +str(col.column_name.lower()) + "), 1, out[" + str(i) + "]);"

            print >>fo, "\t\t\t\t\t\tbreak;"

        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tcount++;"

        print >>fo, "\t\t\t}"
        print >>fo, "\t\t}"

        print >>fo, "\t\tif(count == " + str(attrLen-1) + "){"

        col = schema[tn].column_list[attrLen-1]
        if col.column_type == "INTEGER" or col.column_type == "DATE":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * sizeof(int);"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tmemset(data,0,sizeof(data));"
            print >>fo, "\t\t\tstrncpy(data,buf+prev,i-prev);"
            print >>fo, "\t\t\ttmp."+str(col.column_name.lower()) + " = strtol(data,NULL,10);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(int),1,out["+str(attrLen-1) + "]);"
        elif col.column_type == "DECIMAL":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * sizeof(float);"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tmemset(data,0,sizeof(data));"
            print >>fo, "\t\t\tstrncpy(data,buf+prev,i-prev);"
            print >>fo, "\t\t\ttmp."+str(col.column_name.lower()) + " = atof(data);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(float),1,out["+str(i) + "]);"
        elif col.column_type == "TEXT":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tstrncpy(tmp." + str(col.column_name.lower()) + ",buf+prev,i-prev);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(tmp." +str(col.column_name.lower()) + "), 1, out[" + str(attrLen-1) + "]);"

        print >>fo, "\t\t}"


        print >>fo, "\t}\n" ### end of reading from input file

        print >>fo, "\tfor(i=0;i<" + str(attrLen) + ";i++){"
        print >>fo, "\t\tfclose(out[i]);"
        print >>fo, "\t}"

        print >>fo, "\n}\n"

    print >>fo, "int main(int argc, char ** argv){\n"
    print >>fo, "\tFILE * in = NULL, *out = NULL;"
    print >>fo, "\tint table;"
    print >>fo, "\tint setPath = 0;"
    print >>fo, "\tchar path[PATH_MAX];"
    print >>fo, "\tchar cwd[PATH_MAX];"
    print >>fo, "\t"
    print >>fo, "\tint long_index;"

    print >>fo, "\tstruct option long_options[] = {"
    for i in range(0, len(schema.keys())):
        print >>fo, "\t\t{\"" + schema.keys()[i].lower()+ "\",required_argument,0,'" + str(i) + "'},"

    print >>fo, "\t\t{\"delimiter\",required_argument,0,'" +str(i+1) + "'},"
    print >>fo, "\t\t{\"datadir\",required_argument,0,'" +str(i+2) + "'}"
    print >>fo, "\t};\n"

    print >>fo, "\twhile((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, "\t\tswitch(table){"
    print >>fo, "\t\t\tcase '6':"
    print >>fo, "\t\t\t\tsetPath = 1;"
    print >>fo, "\t\t\t\tstrcpy(path,optarg);"
    print >>fo, "\t\t\t\tbreak;"
    print >>fo, "\t\t}"
    print >>fo, "\t}\n"

    print >>fo, "\toptind=1;\n"
    print >>fo, "\tgetcwd(cwd,PATH_MAX);"

    print >>fo, "\twhile((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, "\t\tswitch(table){"
    for i in range(0, len(schema.keys())):
        print >>fo, "\t\t\tcase '" + str(i) + "':"
        print >>fo, "\t\t\t\tin = fopen(optarg,\"r\");"
        print >>fo, "\t\t\t\tif(!in){"
        print >>fo, "\t\t\t\t\tprintf(\"Failed to open %s\\n\",optarg);"
        print >>fo, "\t\t\t\t\texit(-1);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tif (setPath == 1){"
        print >>fo, "\t\t\t\t\tchdir(path);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\t" + schema.keys()[i].lower() + "(in,\"" + schema.keys()[i] + "\");"
        print >>fo, "\t\t\t\tif (setPath == 1){"
        print >>fo, "\t\t\t\t\tchdir(cwd);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tfclose(in);"
        print >>fo, "\t\t\t\tbreak;"

    print >>fo, "\t\t\tcase '" + str(i+1) + "':"
    print >>fo, "\t\t\t\tdelimiter = optarg[0];"
    print >>fo, "\t\t\t\tbreak;"
    print >>fo, "\t\t}"
    print >>fo, "\t}\n"

    print >>fo, "\treturn 0;"

    print >>fo, "}\n"

    fo.close()

class columnAttr(object):
    type = None
    size = None

    def __init__ (self):
        self.type = ""
        self.size = 0

class JoinTranslation(object):
    dimTables = None
    factTables = None
    joinNode = None
    dimIndex = None
    factIndex = None
    outIndex = None
    outAttr = None
    outPos = None

    def __init__ (self):
        self.dimTables = []
        self.factTables = []
        self.joinNode = []
        self.dimIndex = []
        self.factIndex = []
        self.outIndex = []
        self.outAttr = []
        self.outPos = []

    def __repr__(self):
        print "dimTables: ", self.dimTables
        print "factTables: ", self.factTables
        print "joinNode: ", self.joinNode
        print "dimIndex: ", self.dimIndex
        print "factIndex: ", self.factIndex
        print "outIndex: ", self.outIndex
        print "outAttr: ", self.outAttr
        print "outPos: ", self.outPos

def __get_gb_exp__(exp,tmp_list):
    if not isinstance(exp,ystree.YFuncExp):
        return

    if exp.func_name in ["SUM","AVG","COUNT","MAX","MIN"]:
        tmp_list.append(exp)
    else:
        for x in exp.parameter_list:
            __get_gb_exp__(x,tmp_list)


def get_gbexp_list(exp_list,gb_exp_list):
    for exp in exp_list:
        if not isinstance(exp,ystree.YFuncExp):
            continue
        tmp_list = []
        __get_gb_exp__(exp,tmp_list)
        for tmp in tmp_list:
            tmp_bool = False
            for gb_exp in gb_exp_list:
                if tmp.compare(gb_exp) is True:
                    tmp_bool = True
                    break
            if tmp_bool is False:
                gb_exp_list.append(tmp)

"""
get_tables() gets the translation information for join, agg and order by nodes. 
Currently we only support star schema queries.
We assume that the dimTable is always the right child of the join node. 
"""

def get_tables(tree, joinAttr, aggNode, orderbyNode):

    # The leaf is the fact table
    if isinstance(tree, ystree.TableNode):
        joinAttr.factTables.append(tree)
        return

    # copy into orderbyNode
    elif isinstance(tree, ystree.OrderByNode):
        obNode = copy.deepcopy(tree)
        orderbyNode.append(obNode)
        get_tables(tree.child, joinAttr, aggNode, orderbyNode)

    # copy into aggNode
    elif isinstance(tree, ystree.GroupByNode):

        gbNode = copy.deepcopy(tree)
        aggNode.append(gbNode)
        get_tables(tree.child, joinAttr, aggNode, orderbyNode)

    elif isinstance(tree, ystree.TwoJoinNode):
        
        leftIndex = []
        rightIndex = []
        leftAttr = []
        rightAttr = []
        leftPos = []
        rightPos = []

        # copy into joinAttr
        newNode = copy.deepcopy(tree)
        joinAttr.joinNode.insert(0,newNode)

        for exp in tree.select_list.tmp_exp_list:

            index = tree.select_list.tmp_exp_list.index(exp)
            if isinstance(exp,ystree.YRawColExp):
                colAttr = columnAttr()
                colAttr.type = exp.column_type
                if exp.table_name == "LEFT":

                    if joinType == 0:
                        leftIndex.append(exp.column_name)

                    elif joinType == 1:
                        newExp = ystree.__trace_to_leaf__(tree,exp,False) # Get the real table name
                        leftIndex.append(newExp.column_name)

                    leftAttr.append(colAttr)
                    leftPos.append(index)

                elif exp.table_name == "RIGHT":

                    if joinType == 0:
                        rightIndex.append(exp.column_name)

                    elif joinType == 1:
                        newExp = ystree.__trace_to_leaf__(tree,exp,False)
                        rightIndex.append(newExp.column_name)

                    rightAttr.append(colAttr)
                    rightPos.append(index)

        # index: column id in the original table
        outList= []
        outList.append(leftIndex)
        outList.append(rightIndex)

        # attr: column name in the original table
        outAttr = []
        outAttr.append(leftAttr)
        outAttr.append(rightAttr)

        # pos: column id in the join table
        outPos = []
        outPos.append(leftPos)
        outPos.append(rightPos)

        joinAttr.outIndex.insert(0,outList)
        joinAttr.outAttr.insert(0, outAttr)
        joinAttr.outPos.insert(0, outPos)

        pkList = tree.get_pk()
        # def exp_list_to_str(exp_list):
        #     return map(lambda exp: exp.evaluate(), exp_list)
        # print "pkList[0]: ", exp_list_to_str(pkList[0])
        # print "pkList[1]: ", exp_list_to_str(pkList[1])

        if (len(pkList[0]) != len(pkList[1])):
            print 1/0

        if joinType == 0:
            for exp in pkList[0]:
                colIndex = 0
                if isinstance(tree.left_child, ystree.TableNode):
                    colIndex = -1
                    for tmp in tree.left_child.select_list.tmp_exp_list:
                        if exp.column_name == tmp.column_name:
                            colIndex = tree.left_child.select_list.tmp_exp_list.index(tmp)
                            break
                    if colIndex == -1:
                        print 1/0
                else:
                    colIndex = exp.column_name

        elif joinType == 1:
            for exp in pkList[0]:
                newExp = ystree.__trace_to_leaf__(tree,exp,True)
                colIndex = newExp.column_name

        joinAttr.factIndex.insert(0, colIndex)

        for exp in pkList[1]:
            colIndex = 0
            if isinstance(tree.right_child, ystree.TableNode):
                colIndex = -1
                for tmp in tree.right_child.select_list.tmp_exp_list:
                    if exp.column_name == tmp.column_name:
                        colIndex = tree.right_child.select_list.tmp_exp_list.index(tmp)
                        break
                if colIndex == -1:
                    print 1/0
            else:
                colIndex = exp.column_name
            joinAttr.dimIndex.insert(0, colIndex)

        if isinstance(tree.right_child, ystree.TableNode):
            joinAttr.dimTables.insert(0, tree.right_child)

        get_tables(tree.left_child, joinAttr, aggNode, orderbyNode)


"""
Translate the type defined in the schema into the supported
type in the translated c program.
Currently only three types are supported:
    INT, FLOAT and STRING.
"""

def to_ctype(colType):

    if colType in ["INTEGER","DATE"]:
        return "INT";
    elif colType in ["TEXT"]:
        return "STRING"
    elif colType in ["DECIMAL"]:
        return "FLOAT"

"""
Get the length of a given column.
"""

def type_length(tn, colIndex, colType):
    if colType in ["INTEGER", "DATE"]:
        return "sizeof(int)"
    elif colType in ["TEXT"]:
        colLen = schema[tn].column_list[colIndex].column_others
        return str(colLen)
    elif colType in ["DECIMAL"]:
        return "sizeof(float)"

"""
Get the exp information from the where expresion.
"""

def get_where_attr(exp, whereList, relList, conList):
    if isinstance(exp, ystree.YFuncExp):
        if exp.func_name in ["AND", "OR"]:
            for x in exp.parameter_list:
                if isinstance(x, ystree.YFuncExp):
                    get_where_attr(x,whereList, relList, conList)
                elif isinstance(x, ystree.YRawColExp):
                    whereList.append(x)
        else:
            relList.append(exp.func_name)
            for x in exp.parameter_list:
                if isinstance(x, ystree.YRawColExp):
                    whereList.append(x)
                elif isinstance(x, ystree.YConsExp):
                    if x.ref_col != None:
                        conList.append(x.ref_col)
                    else:
                        conList.append(x.cons_value)
                elif isinstance(x, ystree.YFuncExp) and x.func_name == "SUBQ":
                    conList.append(x)

    elif isinstance(exp, ystree.YRawColExp):
        whereList.append(exp)


"""
Generate a new where list where no duplate columns exist.
Return the number of columns in the new list.
"""

def count_whereList(wlist, tlist):

    for col in wlist:
        colExist = False
        for x in tlist:
            if x.compare(col) is True:
                colExist = True
                break
        if colExist is False:
            tlist.append(col)

    return len(tlist)

"""
count the nested level of the where condition.
"""

def count_whereNested(exp):
    count = 0

    if isinstance(exp, ystree.YFuncExp):
        if exp.func_name in ["AND", "OR"]:
            for x in exp.parameter_list:
                max = 0
                if isinstance(x,ystree.YFuncExp) and x.func_name in ["AND","OR"]:
                    max +=1
                    max += count_whereNest(x)
                    if max > count:
                        count = max

    return count

class mathExp:
    opName = None
    leftOp = None
    rightOp = None
    value = None

    def __init__(self):
        self.opName = None
        self.leftOp = None
        self.rightOp = None
        self.value = None

    def addOp(self, exp):

        if isinstance(exp,ystree.YRawColExp):
            self.opName = "COLUMN"
            self.value = exp.column_name
        elif isinstance(exp,ystree.YConsExp):
            self.opName = "CONS"
            self.value = exp.cons_value
        elif isinstance(exp,ystree.YFuncExp):
            self.opName = exp.func_name
            leftExp = exp.parameter_list[0]
            rightExp = exp.parameter_list[1]

            self.leftOp = mathExp()
            self.rightOp = mathExp() 
            self.leftOp.addOp(leftExp)
            self.rightOp.addOp(rightExp)

### print the mathExp in c

def printMathFunc(fo,prefix, mathFunc):

    if mathFunc.opName == "COLUMN":
        print >>fo, prefix + ".op = NOOP;" 
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = COLUMN;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    elif mathFunc.opName == "CONS":
        print >>fo, prefix + ".op = NOOP;" 
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = CONS;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    else:
        print >>fo, prefix + ".op = " + mathFunc.opName + ";"
        print >>fo, prefix + ".opNum = 2;"
        print >>fo, prefix + ".exp = (long) malloc(sizeof(struct mathExp) * 2);"
        prefix1 = "((struct mathExp *)" + prefix + ".exp)[0]"
        prefix2 = "((struct mathExp *)"+ prefix + ".exp)[1]"
        printMathFunc(fo,prefix1,mathFunc.leftOp)
        printMathFunc(fo,prefix2,mathFunc.rightOp)

"""
generate_col_list gets all the columns that will be scannned for a given table node.
@indexList stores the index of each column.
@colList stores the columnExp for each column. 
"""

def generate_col_list(tn,indexList, colList):

    for col in tn.select_list.tmp_exp_list:
        if col.column_name not in indexList:
            indexList.append(col.column_name)
            colList.append(col)

    if tn.where_condition is not None:
        whereList = []
        relList = []
        conList = []
        get_where_attr(tn.where_condition.where_condition_exp,whereList,relList,conList)
        for col in whereList:
            if col.column_name not in indexList:
                indexList.append(col.column_name)
                colList.append(col)
        for con in conList:
            if isinstance(con, ystree.YFuncExp) and con.func_name == "SUBQ":
                for par in con.parameter_list:
                    if isinstance(par, ystree.YRawColExp) and par.column_name not in indexList:
                        indexList.append(par.column_name)
                        colList.append(par)
                        



"""
generate_code generates CUDA/OpenCL codes from the query plan tree.
Currently we only generate CUDA/OpenCL codes for star schema queries.

Several configurable variables (in config.py):
    @CODETYPE determines whether CUDA or OpenCL codes should be generated.
    0 represents CUDA and 1 represents OpenCL.

    @joinType determines whether we should generate invisible joins for star
    schema queries. 0 represents normal join and 1 represents invisible join.
    
    @POS describes where the data are stored in the host memory and how the
    codes should be generated. 0 means data are stored in pageable host
    memory and data are explicitly transferred. 1 means data are stored in
    pinned host memory and data are explicitly transferred. 2 means data are
    stored in pinned host memory and the kernel will directly access the data
    without explicit data transferring. 3 means data are stored in disk and only
    mapped to host memory.
"""

def generate_code(tree):

    global baseIndent
    """
    First check whether the value of each configurable variable is valid.
    All should be integers.
    """

    if CODETYPE not in [0,1]:
        print "Error! The value of CODETYPE can only be 0 or 1."
        exit(-1)

    if POS not in [0,1,2,3]:
        print "Error! The value of POS can only be 0,1,2,3."
        exit(-1)

    if joinType not in [0,1]:
        print "Error! The value of JOINTYPE can only be 0 or 1."
        exit(-1)

    DTYPE_STR = ""
    if CODETYPE == 1:
        if PID not in [0,1,2,3]:
            print "Error for PID!"
            exit(-1)

        if DTYPE not in [0,1,2]:
            print "Error! The value of DTYPE can only be 0,1,2."
            exit(-1)

        if DTYPE == 0:
            DTYPE_STR = "CL_DEVICE_TYPE_GPU"
        elif DTYPE == 1:
            DTYPE_STR = "CL_DEVICE_TYPE_CPU"
        elif DTYPE == 2:
            DTYPE_STR = "CL_DEVICE_TYPE_ACCELERATOR"

    if CODETYPE==0:
        fo = open("driver.cu","w")
    else:
        fo = open("driver.cpp","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#include <stdio.h>"
    print >>fo, "#include <stdlib.h>"
    print >>fo, "#include <sys/types.h>"
    print >>fo, "#include <sys/stat.h>"
    print >>fo, "#include <fcntl.h>"
    print >>fo, "#include <sys/mman.h>"
    print >>fo, "#include <string.h>"
    print >>fo, "#include <unistd.h>"
    print >>fo, "#include <malloc.h>"
    print >>fo, "#include <time.h>"
    print >>fo, "#include <getopt.h>"
    print >>fo, "#include <linux/limits.h>"
    print >>fo, "#include \"../include/common.h\""

    if joinType == 0:
        print >>fo, "#include \"../include/hashJoin.h\""
    else:
        print >>fo, "#include \"../include/inviJoin.h\""

    print >>fo, "#include \"../include/schema.h\""

    if CODETYPE == 0:   
        print >>fo, "#include \"../include/cpuCudaLib.h\""
        print >>fo, "#include \"../include/gpuCudaLib.h\""

        print >>fo, "extern struct tableNode* tableScan(struct scanNode *,struct statistic *);"
        if joinType == 0:
            print >>fo, "extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);"
        else:
            print >>fo, "extern struct tableNode* inviJoin(struct joinNode *, struct statistic *);"
        print >>fo, "extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);"
        print >>fo, "extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);"
        print >>fo, "extern char* materializeCol(struct materializeNode * mn, struct statistic *);"

    else:              
        print >>fo, "#include <CL/cl.h>"
        print >>fo, "#include <string>"
        print >>fo, "#include \"../include/gpuOpenclLib.h\"\n"
        print >>fo, "#include\"../include/cpuOpenclLib.h\""
        print >>fo, "using namespace std;"
        print >>fo, "extern const char * createProgram(string, int *);"

        print >>fo, "extern struct tableNode* tableScan(struct scanNode *,struct clContext *, struct statistic *);"
        if joinType == 0:
            print >>fo, "extern struct tableNode* hashJoin(struct joinNode *, struct clContext *, struct statistic *);"
        else:
            print >>fo, "extern struct tableNode* inviJoin(struct joinNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern struct tableNode* groupBy(struct groupByNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern struct tableNode* orderBy(struct orderByNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern char * materializeCol(struct materializeNode * mn, struct clContext *, struct statistic *);"

    indent = baseIndent
    print >>fo, "\n#define CHECK_POINTER(p) do {\\"
    print >>fo, indent + "if(p == NULL){   \\"
    print >>fo, indent + baseIndent + "perror(\"Failed to allocate host memory\");    \\"
    print >>fo, indent + baseIndent + "exit(-1);      \\"
    print >>fo, indent + "}} while(0)"

    print >>fo, "\nint main(int argc, char ** argv){\n"
    
    if CODETYPE == 1:
        print >>fo, indent + "int psc = 0;"
        print >>fo, indent + "void * clTmp;"
        print >>fo, indent + "const char * ps = createProgram(\"kernel.cl\",&psc);"
        print >>fo, indent + "struct clContext context;"
        print >>fo, indent + "cl_uint numP;"
        print >>fo, indent + "cl_int error = 0;"
        print >>fo, indent + "cl_device_id device;"
        print >>fo, indent + "clGetPlatformIDs(0,NULL,&numP);"
        print >>fo, indent + "cl_platform_id * pid = new cl_platform_id[numP];"
        print >>fo, indent + "clGetPlatformIDs(numP, pid, NULL);"
        print >>fo, indent + "clGetDeviceIDs(pid[" + str(PID) + "]," + DTYPE_STR +", 1, &device, NULL);"
        print >>fo, indent + "context.context = clCreateContext(0, 1, &device, NULL, NULL, &error);"
        print >>fo, indent + "cl_command_queue_properties prop = 0;"
        print >>fo, indent + "prop |= CL_QUEUE_PROFILING_ENABLE;"
        print >>fo, indent + "context.queue = clCreateCommandQueue(context.context, device, prop, &error);"
        print >>fo, indent + "context.program = clCreateProgramWithSource(context.context, psc, (const char **)&ps, 0, &error);"
        print >>fo, indent + "error = clBuildProgram(context.program, 0, 0 , \"-I .\" , 0, 0);\n"

    else:
        print >>fo, indent + "/* For initializing CUDA device */"
        print >>fo, indent + "int * cudaTmp;"
        print >>fo, indent + "cudaMalloc((void**)&cudaTmp,sizeof(int));"
        print >>fo, indent + "cudaFree(cudaTmp);\n"


    print >>fo, indent + "int table;"
    print >>fo, indent + "int long_index;"
    print >>fo, indent + "char path[PATH_MAX];"
    print >>fo, indent + "int setPath = 0;"
    print >>fo, indent + "struct option long_options[] = {"
    print >>fo, indent + baseIndent + "{\"datadir\",required_argument,0,'0'}"
    print >>fo, indent + "};\n"

    print >>fo, indent + "while((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, indent + baseIndent + "switch(table){"
    print >>fo, indent + baseIndent * 2 + "case '0':"
    print >>fo, indent + baseIndent * 3 + "setPath = 1;"
    print >>fo, indent + baseIndent * 3 + "strcpy(path,optarg);"
    print >>fo, indent + baseIndent * 3 + "break;"
    print >>fo, indent + baseIndent + "}"
    print >>fo, indent + "}\n"

    print >>fo, indent + "if(setPath == 1)"
    print >>fo, indent + baseIndent + "chdir(path);\n"

    print >>fo, indent + "struct timespec start, end;"
    print >>fo, indent + "struct timespec diskStart, diskEnd;"
    print >>fo, indent + "double diskTotal = 0;"
    print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&start);"
    print >>fo, indent + "struct statistic pp;"
    print >>fo, indent + "pp.total = pp.kernel = pp.pcie = 0;\n"

    generate_code_for_a_tree(fo, tree, 0, True)

    print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &end);"
    print >>fo, indent + "double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;"
    print >>fo, indent + "printf(\"Disk Load Time: %lf\\n\", diskTotal/(1000*1000));"
    print >>fo, indent + "printf(\"PCIe Time: %lf\\n\",pp.pcie);"
    print >>fo, indent + "printf(\"Kernel Time: %lf\\n\",pp.kernel);"
    print >>fo, indent + "printf(\"Total Time: %lf\\n\", timeE/(1000*1000));"
    print >>fo, "}\n"

    fo.close()


def get_subqueries(tree, subq_list):

    if isinstance(tree, ystree.OrderByNode) or isinstance(tree, ystree.GroupByNode):
        get_subqueries(tree.child, subq_list)

    elif isinstance(tree, ystree.TwoJoinNode):
        get_subqueries(tree.left_child, subq_list)
        get_subqueries(tree.right_child, subq_list)

    elif isinstance(tree, ystree.TableNode) and tree.where_condition != None:
        where_exp = tree.where_condition.where_condition_exp
        def __get_subqueries__(exp, subq_list):
            if exp is None or not isinstance(exp, ystree.YFuncExp):
                return
            if exp.func_name != "SUBQ":
                map(lambda par: __get_subqueries__(par, subq_list), exp.parameter_list)
            else:
                subq_list.append(exp)

        __get_subqueries__(where_exp, subq_list)
        return


def generate_code_for_a_tree(fo, tree, lvl, mat_f):

    global baseIndent
    indent_this_level = (lvl * 3 + 1) * baseIndent
    indent = indent_this_level

    var_subqRes = "subqRes" + str(lvl)

    print ">>> Generate code for a tree <<<"
    tree.debug(0)

    resultNode = "result"
    joinAttr = JoinTranslation()
    aggNode = []
    orderbyNode = []

    get_tables(tree, joinAttr, aggNode, orderbyNode)

    print >>fo, indent + "struct tableNode *" + resultNode + " = (struct tableNode*) malloc(sizeof(struct tableNode));"
    print >>fo, indent + "CHECK_POINTER(" + resultNode + ");"
    print >>fo, indent + "initTable(" + resultNode + ");"
    print >>fo, indent + "char * " + var_subqRes + ";\n"

    """
    Scan all the dimension tables first.
    """

    print >>fo, indent + "// dimension tables: " + str(map(lambda tn: tn.table_name.upper(), joinAttr.dimTables))
    for tn in joinAttr.dimTables:
        print >>fo, indent + "struct tableNode *" + tn.table_name.lower() +"Table;"

    print >>fo, indent + "int outFd;"
    print >>fo, indent + "long outSize;"
    print >>fo, indent + "char *outTable;"
    print >>fo, indent + "long offset, tupleOffset;"
    print >>fo, indent + "int blockTotal;"
    print >>fo, indent + "struct columnHeader header;\n"

    for tn in joinAttr.dimTables:

        resName = tn.table_name.lower() + "Res"
        tnName = tn.table_name.lower() + "Table"
        print >>fo, indent + "// Load columns from the table " + tn.table_name.upper()

        indexList = []
        colList = []
        generate_col_list(tn, indexList, colList)

        totalAttr = len(indexList)
        setTupleNum = 0
        tupleSize = "0"

        selectList = tn.select_list.tmp_exp_list

        for i in range(0,totalAttr):
            col = colList[i]
            ctype = to_ctype(col.column_type)
            colIndex = int(col.column_name)
            colLen = type_length(tn.table_name, colIndex, col.column_type)
            tupleSize += " + " + colLen

            print >>fo, indent + "outFd = open(\""+tn.table_name+str(colIndex)+"\", O_RDONLY);"
            print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"

            if setTupleNum == 0:
                setTupleNum = 1
                print >>fo, indent + "blockTotal = header.blockTotal;"
                print >>fo, indent + "close(outFd);"
                break

        print >>fo, indent + "offset = 0;"
        print >>fo, indent + "tupleOffset = 0;"
        print >>fo, indent + "struct tableNode *" + resName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
        print >>fo, indent + "CHECK_POINTER("+ resName + ");"
        print >>fo, indent + "initTable(" + resName + ");"
        print >>fo, indent + "for(int i = 0; i < blockTotal; i++){\n"

        indent = indent_this_level + baseIndent

        print >>fo, indent + "// Table initialization"
        print >>fo, indent + tnName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
        print >>fo, indent + "CHECK_POINTER(" + tnName + ");"
        print >>fo, indent + tnName + "->totalAttr = " + str(totalAttr) + ";"
        print >>fo, indent + tnName + "->attrType = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrType);"
        print >>fo, indent + tnName + "->attrSize = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrSize);"
        print >>fo, indent + tnName + "->attrIndex = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrIndex);"
        print >>fo, indent + tnName + "->attrTotalSize = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrTotalSize);"
        print >>fo, indent + tnName + "->dataPos = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataPos);"
        print >>fo, indent + tnName + "->dataFormat = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataFormat);"
        print >>fo, indent + tnName + "->content = (char **)malloc(sizeof(char *)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + tnName + "->content);\n"

        for i in range(0,totalAttr):
            col = colList[i]
            ctype = to_ctype(col.column_type)
            colIndex = int(col.column_name)
            colLen = type_length(tn.table_name, colIndex, col.column_type)
            tupleSize += " + " + colLen

            print >>fo, indent + "// Load column " + str(colIndex) + ", type: " + col.column_type
            print >>fo, indent + tnName + "->attrSize[" + str(i) + "] = " + colLen + ";"
            print >>fo, indent + tnName + "->attrIndex["+ str(i) + "] = " + str(colIndex) + ";"
            print >>fo, indent + tnName + "->attrType[" + str(i) + "] = " + ctype + ";"

            if POS == 0:
                print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"
            elif POS == 1:
                print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = PINNED;"
            elif POS == 2:
                print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = UVA;"
            elif POS == 3:
                print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MMAP;"
            else:
                print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"

            print >>fo, indent + "outFd = open(\"" + tn.table_name + str(colIndex) + "\", O_RDONLY);"
            print >>fo, indent + "offset = i * sizeof(struct columnHeader) + tupleOffset * " + str(colLen) + ";"
            print >>fo, indent + "lseek(outFd, offset, SEEK_SET);"
            print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
            print >>fo, indent + "offset += sizeof(struct columnHeader);"
            print >>fo, indent + tnName + "->dataFormat[" + str(i) + "] = header.format;"

            print >>fo, indent + "outSize = header.tupleNum * " + colLen + ";"
            print >>fo, indent + tnName + "->attrTotalSize[" + str(i) + "] = outSize;\n"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
            print >>fo, indent + "outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"

            if CODETYPE == 0:
                if POS == 1:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName + "->content[" + str(i) + "], outSize));"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 2:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName+"->content["+str(i)+"], outSize));"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 3:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
                else:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"

            else:
                if POS == 0:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 3:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
                else:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)clCreateBuffer(context.context, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, outSize, NULL, 0);"
                    print >>fo, indent + "clTmp = clEnqueueMapBuffer(context.queue,(cl_mem)" + tnName + "->content[" + str(i) + "],CL_TRUE,CL_MAP_WRITE,0,outSize,0,0,0,0);"
                    print >>fo, indent + "memcpy(clTmp,outTable,outSize);"
                    print >>fo, indent + "clEnqueueUnmapMemObject(context.queue,(cl_mem)" + tnName + "->content[" + str(i) + "],clTmp,0,0,0);"


            print >>fo, indent + "munmap(outTable, outSize);"
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

            print >>fo, indent + "close(outFd);\n"

        print >>fo, indent + tnName + "->tupleSize = " + tupleSize + ";"
        print >>fo, indent + tnName + "->tupleNum = header.tupleNum;\n"

        if tn.where_condition is not None:
            whereList = []
            relList = []
            conList = []

            get_where_attr(tn.where_condition.where_condition_exp, whereList, relList, conList)
            newWhereList = []
            whereLen = count_whereList(whereList, newWhereList)
            nested = count_whereNested(tn.where_condition.where_condition_exp)

            if nested != 0:
                print "Not supported yet: the where expression is too complicated"
                print 1/0

            relName = tn.table_name.lower() + "Rel"
            print >>fo, indent + "// Where conditions: " + tn.where_condition.where_condition_exp.evaluate()
            print >>fo, indent + "struct scanNode " + relName + ";"
            print >>fo, indent + relName + ".tn = " + tnName + ";"
            print >>fo, indent + relName + ".hasWhere = 1;"
            print >>fo, indent + relName + ".whereAttrNum = " + str(whereLen) + ";"
            print >>fo, indent + relName + ".whereIndex = (int *)malloc(sizeof(int)*" + str(len(whereList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".whereIndex);"
            print >>fo, indent + relName + ".outputNum = " + str(len(selectList)) + ";"
            print >>fo, indent + relName + ".outputIndex = (int *)malloc(sizeof(int) * " + str(len(selectList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".outputIndex);"

            for i in range(0,len(selectList)):
                colIndex = selectList[i].column_name
                outputIndex = indexList.index(colIndex)
                print >>fo, indent + relName + ".outputIndex[" + str(i) + "] = " + str(outputIndex) + ";"

            for i in range(0,len(newWhereList)):
                colIndex = indexList.index(newWhereList[i].column_name)
                print >>fo, indent + relName + ".whereIndex["+str(i) + "] = " + str(colIndex) + ";"

            if keepInGpu ==0:
                print >>fo, indent + relName + ".KeepInGpu = 0;"
            else:
                print >>fo, indent + relName + ".keepInGpu = 1;"

            print >>fo, indent + relName + ".filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".filter);"

            print >>fo, indent + "(" + relName + ".filter)->nested = 0;"
            print >>fo, indent + "(" + relName + ".filter)->expNum = " + str(len(whereList)) + ";"
            print >>fo, indent + "(" + relName + ".filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *" + str(len(whereList)) + ");"
            print >>fo, indent + "CHECK_POINTER((" + relName + ".filter)->exp);"

            if tn.where_condition.where_condition_exp.func_name in ["AND","OR"]:
                print >>fo, indent + "(" + relName + ".filter)->andOr = " + tn.where_condition.where_condition_exp.func_name + ";"

            else:
                print >>fo, indent + "(" + relName + ".filter)->andOr = EXP;"

            for i in range(0,len(whereList)):
                colIndex = -1
                for j in range(0,len(newWhereList)):
                    if newWhereList[j].compare(whereList[i]) is True:
                        colIndex = j
                        break

                if colIndex <0:
                    print 1/0

                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].index    = " + str(colIndex) + ";"
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + ";"
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = MEM;"

                colType = whereList[i].column_type
                ctype = to_ctype(colType)

                if ctype == "INT":
                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "int tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(int));"
                    print >>fo, indent + "}"

                elif ctype == "FLOAT":
                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "float tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(float));"
                    print >>fo, indent + "}"

                else:
                    print >>fo, indent + "strcpy((" + relName + ".filter)->exp[" + str(i) + "].content, " + conList[i] + ");\n"

            if CODETYPE == 0:
                print >>fo, indent + "struct tableNode *tmp = tableScan(&" + relName + ", &pp);"
            else:
                print >>fo, indent + "struct tableNode *tmp = tableScan(&" + relName + ", &context, &pp);"

            print >>fo, indent + "if(blockTotal != 1){"

            if CODETYPE == 0:
                print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + ", tmp, &pp);"
            else:
                print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + ", tmp, &context, &pp);"

            print >>fo, indent + "}else{"
            print >>fo, indent + baseIndent + "free(" + resName + ");"
            print >>fo, indent + baseIndent + resName + " = tmp;"
            print >>fo, indent + "}"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
            print >>fo, indent + "freeScan(&" + relName + ");\n"
            if CODETYPE == 1:
                print >>fo, indent + "clFinish(context.queue);"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

############## end of wherecondition not none

        else:
            print >>fo, indent + "if(blockTotal != 1){"

            indent = indent_this_level + 2 * baseIndent
            if CODETYPE == 0:
                print >>fo, indent + "mergeIntoTable(" + resName + "," + tnName +", &pp);"
            else:
                print >>fo, indent + "mergeIntoTable(" + resName + "," + tnName +", &context, &pp);"
                
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
            print >>fo, indent + "freeTable(" + tnName + ");"
            if CODETYPE == 1:
                print >>fo, indent + "clFinish(context.queue);"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
            indent = indent_this_level + baseIndent
            print >>fo, indent + "}else{"
            indent = indent_this_level + 2 * baseIndent
            print >>fo, indent + "free(" + resName + ");"
            print >>fo, indent + resName + " = " + tnName + ";"
            indent = indent_this_level + baseIndent
            print >>fo, indent + "}"

        indent = indent_this_level + baseIndent
        print >>fo, indent + "tupleOffset += header.tupleNum;"
        indent = indent_this_level
        print >>fo, indent + "}\n"


    intent = indent_this_level
    if joinType == 0:
        """
        Generate the codes for star schema joins.
        0 represents normal hash join and 1 represents invisible join.
        """

        selectOnly = len(joinAttr.dimTables) == 0
        hasWhere = 0
        factName = joinAttr.factTables[0].table_name.lower() + "Table"
        resName = joinAttr.factTables[0].table_name.lower() + "Res"
        setTupleNum = 0
        factTN = joinAttr.factTables[0]

        selectList = joinAttr.factTables[0].select_list.tmp_exp_list

        indexList = []
        colList = []
        generate_col_list(joinAttr.factTables[0], indexList, colList)
        totalAttr = len(indexList)
        print >>fo, indent + "// Load the fact table: " + joinAttr.factTables[0].table_name.upper()

        print "fact table: ", joinAttr.factTables[0].table_name
        print "  select list: ", map(lambda c : c.evaluate(), selectList)
        print "  index list: ", indexList
        print "  column list: ", map(lambda c : c.evaluate(), colList)

        for i in range(0,totalAttr):
            col = colList[i] 
            if isinstance(col, ystree.YRawColExp):
                colType = col.column_type
                colIndex = col.column_name
                ctype = to_ctype(colType)
                colLen = type_length(joinAttr.factTables[0].table_name, colIndex, colType)
            elif isinstance(col, ystree.YConsExp):
                colType = col.cons_type
                ctype = to_ctype(colType)
                if cons_type == "INTEGER":
                    colLen = "sizeof(int)"
                elif cons_type == "FLOAT":
                    colLen = "sizeof(float)"
                else:
                    colLen = str(len(col.cons_value))
            elif isinstance(col, ystree.YFuncExp):
                print 1/0

            if setTupleNum == 0:
                setTupleNum = 1
                print >>fo, indent + "outFd = open(\"" + joinAttr.factTables[0].table_name + str(colIndex) + "\", O_RDONLY);"
                print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
                print >>fo, indent + "blockTotal = header.blockTotal;"
                print >>fo, indent + "close(outFd);"
                break

        print >>fo, indent + "offset = 0;"
        print >>fo, indent + "long blockSize["+str(totalAttr) + "];"
        print >>fo, indent + "for(int i = 0; i < " + str(totalAttr) + "; i++)"
        print >>fo, indent + baseIndent + "blockSize[i] = 0;"
        print >>fo, indent + "for(int i = 0; i < blockTotal; i++){\n"

        indent = indent_this_level + baseIndent
        print >>fo, indent + "// Table node initialization"
        print >>fo, indent + "struct tableNode *" + factName + " = (struct tableNode*)malloc(sizeof(struct tableNode));" 
        print >>fo, indent + "CHECK_POINTER(" + factName + ");"
        print >>fo, indent + factName + "->totalAttr = " + str(totalAttr) + ";"
        print >>fo, indent + factName + "->attrType = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrType);"
        print >>fo, indent + factName + "->attrSize = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrSize);"
        print >>fo, indent + factName + "->attrIndex = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrIndex);"
        print >>fo, indent + factName + "->attrTotalSize = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrTotalSize);"
        print >>fo, indent + factName + "->dataPos = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->dataPos);"
        print >>fo, indent + factName + "->dataFormat = (int *)malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->dataFormat);"
        print >>fo, indent + factName + "->content = (char **)malloc(sizeof(char *)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->content);\n"

        tupleSize = "0"
        for i in range(0, totalAttr):
            col = colList[i] 
            if isinstance(col, ystree.YRawColExp):
                colType = col.column_type
                colIndex = col.column_name
                ctype = to_ctype(colType)
                colLen = type_length(joinAttr.factTables[0].table_name, colIndex, colType)
            elif isinstance(col, ystree.YConsExp):
                colType = col.cons_type
                ctype = to_ctype(colType)
                if cons_type == "INTEGER":
                    colLen = "sizeof(int)"
                elif cons_type == "FLOAT":
                    colLen = "sizeof(float)"
                else:
                    colLen = str(len(col.cons_value))
            elif isinstance(col, ystree.YFuncExp):
                print 1/0

            tupleSize += " + " + colLen
            print >>fo, indent + "// Load the column " + str(colIndex) + ", type: " + ctype
            print >>fo, indent + factName + "->attrType[" + str(i) + "] = " + ctype + ";"
            print >>fo, indent + factName + "->attrSize[" + str(i) + "] = " + colLen + ";"
            print >>fo, indent + factName + "->attrIndex[" + str(i) + "] = " + str(colIndex) + ";"

            if POS == 0:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MEM;"
            elif POS == 1:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = PINNED;"
            elif POS == 2:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = UVA;"
            elif POS == 3:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MMAP;"
            else:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MEM;"

            print >>fo, indent + "outFd = open(\"" + joinAttr.factTables[0].table_name + str(colIndex) + "\", O_RDONLY);"
            print >>fo, indent + "offset = i * sizeof(struct columnHeader) + blockSize[" + str(i) + "];"
            print >>fo, indent + "lseek(outFd, offset, SEEK_SET);"
            print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
            print >>fo, indent + "blockSize[" + str(i) + "] += header.blockSize;"
            print >>fo, indent + "offset += sizeof(struct columnHeader);"
            print >>fo, indent + factName + "->dataFormat[" + str(i) + "] = header.format;"
            print >>fo, indent + "outSize = header.blockSize;\n"
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
            print >>fo, indent + "outTable = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"

            if CODETYPE == 0:
                if POS == 0:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char *)malloc(outSize);"
                    print >>fo, indent + "CHECK_POINTER(" + factName + "->content[" + str(i) + "]);"
                    print >>fo, indent + "memcpy("+factName+"->content[" + str(i) + "], outTable, outSize);"
                elif POS == 1:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void**)&" + factName + "->content[" + str(i) + "], outSize));"
                    print >>fo, indent + "memcpy(" + factName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 2:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void**)&"+factName+"->content[" + str(i) + "], outSize));"
                    print >>fo, indent + "memcpy(" + factName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 3:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
                else:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char*)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + factName + "->content[" + str(i) + "], outTable, outSize);"

            else:
                if POS == 0:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + factName + "->content[" + str(i) + "], outTable, outSize);"
                elif POS == 3:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
                else:
                    print >>fo, indent + factName + "->content["+str(i)+"] = (char *)clCreateBuffer(context.context, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, outSize, NULL, 0);"
                    print >>fo, indent + "clTmp = clEnqueueMapBuffer(context.queue,(cl_mem)"+factName+"->content["+str(i)+"], CL_TRUE, CL_MAP_WRITE, 0, outSize, 0, 0, 0, 0);"
                    print >>fo, indent + "memcpy(clTmp,outTable,outSize);"
                    print >>fo, indent + "clEnqueueUnmapMemObject(context.queue, (cl_mem)"+factName+"->content["+str(i)+"], clTmp, 0, 0, 0);"


            print >>fo, indent + "munmap(outTable, outSize);"
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec) * BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
            print >>fo, indent + "close(outFd);"
            print >>fo, indent + factName + "->attrTotalSize[" + str(i) + "] = outSize;\n"

        print >>fo, indent + factName + "->tupleSize = " + tupleSize + ";"

        print >>fo, indent + factName + "->tupleNum = header.tupleNum;\n"

################# end of reading the needed attributes of fact table from disk ###############

        if joinAttr.factTables[0].where_condition is not None:
            hasWhere = 1
            whereExp = joinAttr.factTables[0].where_condition.where_condition_exp
            whereList = []
            relList = []
            conList = []

            get_where_attr(whereExp, whereList, relList, conList)
            newWhereList = []
            whereLen = count_whereList(whereList, newWhereList)
            nested = count_whereNested(whereExp)

            print "whereList: ", whereList
            print "relList: ", relList
            print "conList: ", conList

            if nested !=0:
                print "Not supported yet: the where expression is too complicated"
                print 1/0

            relName = joinAttr.factTables[0].table_name.lower() + "Rel"
            print >>fo, indent + "// WHERE condition: " + whereExp.evaluate()
            print >>fo, indent + "struct scanNode " + relName + ";"
            print >>fo, indent + relName + ".tn = " + factName + ";"
            print >>fo, indent + relName + ".hasWhere = 1;"
            print >>fo, indent + relName + ".whereAttrNum = " + str(whereLen) + ";"
            print >>fo, indent + relName + ".outputNum = " + str(len(selectList)) + ";"
            print >>fo, indent + relName + ".whereIndex = (int *)malloc(sizeof(int) * " + str(whereLen) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".whereIndex);"
            print >>fo, indent + relName + ".outputIndex = (int *)malloc(sizeof(int) * " + str(len(selectList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".outputIndex);"

            for i in range(0,len(newWhereList)):
                colIndex = indexList.index(newWhereList[i].column_name)
                print >>fo, indent + relName + ".whereIndex["+str(i) + "] = " + str(colIndex) + ";"

            for i in range(0,len(selectList)):
                colIndex = selectList[i].column_name
                outputIndex = indexList.index(colIndex)
                print >>fo, indent + relName + ".outputIndex[" + str(i) + "] = " + str(outputIndex) + ";"

            if keepInGpu == 0:
                print >>fo, indent + relName + ".keepInGpu = 0;"
            else:
                print >>fo, indent + relName + ".keepInGpu = 1;"

            print >>fo, indent + relName + ".filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".filter);"

            print >>fo, indent + "(" + relName + ".filter)->nested = 0;"
            print >>fo, indent + "(" + relName + ".filter)->expNum = " + str(len(whereList)) + ";"
            print >>fo, indent + "(" + relName + ".filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) * " + str(len(whereList)) + ");"
            print >>fo, indent + "CHECK_POINTER((" + relName + ".filter)->exp);"

            if joinAttr.factTables[0].where_condition.where_condition_exp.func_name in ["AND","OR"]:
                print >>fo, indent + "(" + relName + ".filter)->andOr = " + joinAttr.factTables[0].where_condition.where_condition_exp.func_name + ";"

            else:
                print >>fo, indent + "(" + relName + ".filter)->andOr = EXP;"

            for i in range(0,len(whereList)):
                colIndex = -1
                for j in range(0,len(newWhereList)):
                    if newWhereList[j].compare(whereList[i]) is True:
                        colIndex = j
                        break

                if colIndex < 0:
                    print 1/0

                colType = whereList[i].column_type
                ctype = to_ctype(colType)

                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].index    = " + str(colIndex) + ";"

                if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                    print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + "_VEC;"
                else:
                    print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + ";"

                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = MEM;"

                # Get subquery result here
                if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                    subq_id = conList[i].parameter_list[0].cons_value
                    pass_in_cols = conList[i].parameter_list[1:]
                    sub_tree = ystree.subqueries[subq_id]

                    print "the subquery: "
                    sub_tree.debug(0)
                    print "the pass in cols: ", map(lambda c: c.evaluate(), pass_in_cols)

                    subq_select_list = sub_tree.select_list.tmp_exp_list
                    if len(subq_select_list) > 1:
                        print "ERROR: more than one column are selected in a subquery!"
                        sub_tree.debug(0)
                        print 1/0

                    selectItem = subq_select_list[0]
                    subq_res_size = 0
                    if isinstance(selectItem, ystree.YFuncExp):
                        # Assume the aggregation function with only one parameter, i.e., the column
                        subq_res_col = selectItem.parameter_list[0]
                    elif isinstance(selectItem, ystree.YRawColExp):
                        subq_res_col = selectItem
                    else:
                        print "ERROR: Unknown select column type in a subquery: ", selectItem.evaluate
                        print 1/0

                    subq_res_size = type_length(subq_res_col.table_name, subq_res_col.column_name, subq_res_col.column_type)


                    print >>fo, ""
                    print >>fo, indent + "// Process the subquery"
                    for col in pass_in_cols:
                        colLen = type_length(joinAttr.factTables[0].table_name, col.column_name, col.column_type)
                        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
                        print >>fo, indent + "char *" + pass_in_var + " = (char *)malloc(" + colLen + ");"
                        print >>fo, indent + "CHECK_POINTER(" + pass_in_var + ");"

                    print >>fo, indent + var_subqRes + " = (char *)malloc(" + subq_res_size + " * header.tupleNum);"
                    print >>fo, indent + "CHECK_POINTER(" + var_subqRes + ");\n"

                    print >>fo, indent + "for(int tupleid = 0; tupleid < header.tupleNum; tupleid++){"
                    indent = indent_this_level + baseIndent * 2

                    for col in pass_in_cols:
                        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
                        colLen = type_length(joinAttr.factTables[0].table_name, col.column_name, col.column_type)
                        print >>fo, indent + "memcpy(" + pass_in_var + ", (char *)(" + factName + "->content[" +  str(indexList.index(col.column_name)) + "]) + tupleid * " + colLen + ", " + colLen + ");"

                    print >>fo, indent + "{"

                    generate_code_for_a_tree(fo, sub_tree, lvl + 1, False)

                    print >>fo, indent + baseIndent + ""
                    print >>fo, indent + baseIndent + "mempcpy(" + var_subqRes + " + tupleid * " + subq_res_size + ", final, " + subq_res_size + ");"
                    print >>fo, indent + "}"
                    indent = indent_this_level + baseIndent
                    print >>fo, indent + "}"

                    for col in pass_in_cols:
                        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
                        print >>fo, indent + "free(" + pass_in_var + ");"
                    print >>fo, ""



                if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                    print >>fo, indent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, " + var_subqRes + ", sizeof(void *));"
                elif ctype == "INT":
                    if isinstance(conList[i], ystree.YRawColExp):
                        con_value = "*(int *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                    else:
                        con_value = conList[i]
                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "int tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp, sizeof(int));"
                    print >>fo, indent + "}"
                elif ctype == "FLOAT":
                    if isinstance(conList[i], ystree.YRawColExp):
                        con_value = "*(float *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                    else:
                        con_value = conList[i]
                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "float tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp, sizeof(float));"
                    print >>fo, indent + "}"
                    print 1/0
                else:
                    if isinstance(conList[i], ystree.YRawColExp):
                        con_value = "_" + conList[i].table_name + "_" + str(conList[i].column_name)
                    else:
                        con_value = conList[i]
                    print >>fo, indent + "strcpy((" + relName + ".filter)->exp[" + str(i) + "].content, " + con_value + ");\n"


                # if isinstance(conList[i], ystree.YRawColExp):
                #     if ctype == "INT":
                #         conList[i] = "*(int *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                #     elif ctype == "FLOAT":
                #         conList[i] = "*(float *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                #     else:
                #         conList[i] = "_" + conList[i].table_name + "_" + str(conList[i].column_name)
                # elif isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                #     conList[i] = "subq_result"

                # if ctype == "INT":
                #     print >>fo, indent + "{"
                #     print >>fo, indent + baseIndent + "int tmp = " + conList[i] + ";"
                #     print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(int));"
                #     print >>fo, indent + "}"

                # elif ctype == "FLOAT":
                #     print >>fo, indent + "{"
                #     print >>fo, indent + baseIndent + "float tmp = " + conList[i] + ";"
                #     print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(float));"
                #     print >>fo, indent + "}"
                #     print 1/0
                # else:
                #     print >>fo, indent + "strcpy((" + relName + ".filter)->exp[" + str(i) + "].content, " + conList[i] + ");\n"

            if CODETYPE == 0:
                print >>fo, indent + "struct tableNode * " + resName + " = tableScan(&" + relName + ", &pp);"
            else:
                print >>fo, indent + "struct tableNode * " + resName + " = tableScan(&" + relName + ", &context, &pp);"

            if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                print >>fo, indent + "free(" + var_subqRes + ");\n"

            if selectOnly == 0:
                print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
                print >>fo, indent + "freeScan(&" + relName + ");\n"
                if CODETYPE == 1:
                    print >>fo, indent + "clFinish(context.queue);"
                    print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
                    print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

        else:
            hasWhere = 0
            print >>fo, indent + "struct tableNode * " + resName + " = " + factName + ";"

        factName = resName
        for i in range(0,len(joinAttr.dimTables)):
            jName = "jNode" + str(i)
            dimName = joinAttr.dimTables[i].table_name.lower() + "Res"
            print >>fo, indent + "struct joinNode " + jName + ";"
            print >>fo, indent + jName + ".leftTable = " + factName + ";"
            print >>fo, indent + jName + ".rightTable = " + dimName + ";"

            lOutList = joinAttr.outIndex[i][0]
            rOutList = joinAttr.outIndex[i][1]

            lPosList = joinAttr.outPos[i][0]
            rPosList = joinAttr.outPos[i][1]

            lAttrList = joinAttr.outAttr[i][0]
            rAttrList = joinAttr.outAttr[i][1]

            print >>fo, indent + jName + ".totalAttr = " + str(len(rOutList) + len(lOutList)) + ";"
            print >>fo, indent + jName + ".keepInGpu = (int *) malloc(sizeof(int) * " + str(len(rOutList) + len(lOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".keepInGpu);"

            if keepInGpu == 0:
                print >>fo, indent + "for(int k=0; k<" + str(len(rOutList) + len(lOutList))  + "; k++)"
                print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 0;"
            else:
                print >>fo, indent + "for(int k=0; k<" + str(len(rOutList) + len(lOutList))  + "; k++)"
                print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 1;"

            print >>fo, indent + jName + ".rightOutputAttrNum = " + str(len(rOutList)) + ";"
            print >>fo, indent + jName + ".leftOutputAttrNum = " + str(len(lOutList)) + ";"
            print >>fo, indent + jName + ".leftOutputAttrType = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".leftOutputAttrType);"
            print >>fo, indent + jName + ".leftOutputIndex = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".leftOutputIndex);"
            print >>fo, indent + jName + ".leftPos = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".leftPos);"
            print >>fo, indent + jName + ".tupleSize = 0;"
            for j in range(0,len(lOutList)):
                ctype = to_ctype(lAttrList[j].type)
                print >>fo, indent + jName + ".leftOutputIndex[" + str(j) + "] = " + str(lOutList[j]) + ";"
                print >>fo, indent + jName + ".leftOutputAttrType[" + str(j) + "] = " + ctype + ";" 
                print >>fo, indent + jName + ".leftPos[" + str(j) + "] = " + str(lPosList[j]) + ";"
                print >>fo, indent + jName + ".tupleSize += " + factName + "->attrSize[" + str(lOutList[j]) + "];"

            print >>fo, indent + jName + ".rightOutputAttrType = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".rightOutputAttrType);"
            print >>fo, indent + jName + ".rightOutputIndex = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".rightOutputIndex);"
            print >>fo, indent + jName + ".rightPos = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + jName + ".rightPos);"
            for j in range(0,len(rOutList)):
                ctype = to_ctype(rAttrList[j].type)
                print >>fo, indent + jName + ".rightOutputIndex[" + str(j) + "] = " + str(rOutList[j]) + ";"
                print >>fo, indent + jName + ".rightOutputAttrType[" + str(j) + "] = " + ctype + ";"
                print >>fo, indent + jName + ".rightPos[" + str(j) + "] = " + str(rPosList[j]) + ";"
                print >>fo, indent + jName + ".tupleSize += " + dimName + "->attrSize[" + str(rOutList[j]) + "];"

            print >>fo, indent + jName + ".rightKeyIndex = " + str(joinAttr.dimIndex[i]) + ";"
            print >>fo, indent + jName + ".leftKeyIndex = " + str(joinAttr.factIndex[i]) + ";"

            if CODETYPE == 0:
                print >>fo, indent + "struct tableNode *join" + str(i) + " = hashJoin(&" + jName + ",&pp);\n"
            else:
                print >>fo, indent + "struct tableNode *join" + str(i) + " = hashJoin(&" + jName + ", &context, &pp);\n" 

            factName = "join" + str(i)

        if selectOnly == 0:
            print >>fo, indent + "if(blockTotal != 1){"

            indent = indent_this_level + 2 * baseIndent
            if CODETYPE == 0:
                print >>fo, indent + "mergeIntoTable("+resultNode+",join" + str(i) + ", &pp);"
            else:
                print >>fo, indent + "mergeIntoTable("+resultNode+",join" + str(i) + ", &context, &pp);"
                

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
            for i in range(0,len(joinAttr.dimTables)):
                jName = "join" + str(i)
                print >>fo, indent + "freeTable(" + jName + ");"

            if CODETYPE == 1:
                print >>fo, indent + "clFinish(context.queue);"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

            indent = indent_this_level + baseIndent
            print >>fo, indent + "}else{"
            indent = indent_this_level + 2 * baseIndent
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
            print >>fo, indent + "freeTable(" +resultNode + ");"
            print >>fo, indent + resultNode+" = join" + str(i) + ";" 
            for i in range(0,len(joinAttr.dimTables)-1):
                jName = "join" + str(i)
                print >>fo, indent + "freeTable(" + jName + ");"

            if CODETYPE == 1:
                print >>fo, indent + "clFinish(context.queue);"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
            indent = indent_this_level + baseIndent
            print >>fo, indent + "}"

        else:
            indent = indent_this_level + baseIndent
            print >>fo, indent + "if(blockTotal != 1){"

            if CODETYPE == 0:
                print >>fo, indent + baseIndent + "mergeIntoTable("+resultNode+"," + resName + ",&pp);"
            else:
                print >>fo, indent + baseIndent + "mergeIntoTable("+resultNode+"," + resName + ", &context, &pp);"

            print >>fo, indent + "}else{"
            indent = indent_this_level + 2 * baseIndent
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
            print >>fo, indent + "freeTable(" +resultNode + ");"
            print >>fo, indent + resultNode + " = " + resName + ";"

            if CODETYPE == 1:
                print >>fo, indent + "clFinish(context.queue);"

            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

            indent = indent_this_level + baseIndent
            print >>fo, indent + "}"

            if hasWhere != 0:
                indent = indent_this_level + baseIndent
                print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
                print >>fo, indent + "freeScan(&" + relName + ");\n"

                if CODETYPE == 1:
                    print >>fo, indent + "clFinish(context.queue);"

                print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
                print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

        indent = indent_this_level
        print >>fo, indent + "}\n"


    elif joinType == 1:
        """
        Generating codes for invisible join.
        """

        factName = joinAttr.factTables[0].table_name.lower() + "Table"
        resName = joinAttr.factTables[0].table_name.lower() + "Res"
        selectOnly = len(joinAttr.dimTables) == 0
        hasWhere = 0
        setTupleNum = 0

        selectList = joinAttr.factTables[0].select_list.tmp_exp_list

        indexList = []
        colList = []
        generate_col_list(joinAttr.factTables[0],indexList,colList)
        totalAttr = len(indexList)

        for i in range(0,totalAttr):
            col = colList[i] 
            if isinstance(col, ystree.YRawColExp):
                colType = col.column_type
                colIndex = col.column_name
                ctype = to_ctype(colType)
                colLen = type_length(joinAttr.factTables[0].table_name, colIndex, colType)
            elif isinstance(col, ystree.YConsExp):
                colType = col.cons_type
                ctype = to_ctype(colType)
                if cons_type == "INTEGER":
                    colLen = "sizeof(int)"
                elif cons_type == "FLOAT":
                    colLen = "sizeof(float)"
                else:
                    colLen = str(len(col.cons_value))
            elif isinstance(col, ystree.YFuncExp):
                print 1/0

            if setTupleNum == 0:
                setTupleNum = 1
                print >>fo, indent + "outFd = open(\"" + joinAttr.factTables[0].table_name + str(colIndex) + "\",O_RDONLY);"
                print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
                print >>fo, indent + "blockTotal = header.blockTotal;" 
                print >>fo, indent + "close(outFd);"

        factIndex = []
        factInputList = joinAttr.factTables[0].select_list.tmp_exp_list
        dimNum = len(joinAttr.dimTables)
        outputList = joinAttr.joinNode[dimNum-1].select_list.tmp_exp_list
        outputNum =  len(outputList)

        jName = "jNode"
        print >>fo, indent + "struct joinNode " + jName + ";"
        print >>fo, indent + jName + ".dimNum = " + str(dimNum) + ";" 
        print >>fo, indent + jName + ".dimTable = (struct tableNode **) malloc(sizeof(struct tableNode) * " + jName + ".dimNum);"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".dimTable);"
        print >>fo, indent + jName + ".factIndex = (int *) malloc(sizeof(int) * " + jName + ".dimNum);"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".factIndex);"
        print >>fo, indent + jName + ".dimIndex = (int *) malloc(sizeof(int) * " + jName + ".dimNum);\n"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".dimIndex);"

        for i in joinAttr.factIndex:
            for j in range(0, len(factInputList)):
                if i == factInputList[j].column_name:
                    break
                factIndex.append(j)

        for i in range(0, dimNum):
            print >>fo, indent + jName + ".dimIndex[" + str(i) + "] = " + str(joinAttr.dimIndex[i]) + ";"
            print >>fo, indent + jName + ".factIndex[" + str(i) + "] = " + str(factIndex[i]) + ";"
            dimName = joinAttr.dimTables[i].table_name.lower() + "Res"
            print >>fo, indent + jName + ".dimTable["+str(i) + "] = " + dimName + ";\n"

        print >>fo, indent + jName + ".totalAttr = " + str(outputNum) + ";"
        print >>fo, indent + jName + ".keepInGpu = (int *) malloc(sizeof(int) * " + str(outputNum) + ");"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".keepInGpu);"

        if keepInGpu == 0:
            print >>fo, indent + "for(int k = 0; k < " + str(outputNum)  + "; k++)"
            print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 0;\n"
        else:
            print >>fo, indent + "for(int k=0;k<" + str(outputNum)  + ";k++)"
            print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 1;\n"

        print >>fo, indent + jName +".attrType = (int *) (malloc(sizeof(int) * "+ jName + ".totalAttr));"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".attrType);"
        print >>fo, indent + jName +".attrSize = (int *) (malloc(sizeof(int) * "+ jName + ".totalAttr));"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".attrSize);"

        tupleSize = "0"

        for i in range(0, outputNum):
            colType = outputList[i].column_type
            ctype = to_ctype(colType)
            newExp = ystree.__trace_to_leaf__(joinAttr.joinNode[dimNum-1], outputList[i], False)
            colLen = type_length(newExp.table_name,newExp.column_name,colType)
            tupleSize = tupleSize + "+" + colLen
            print >>fo, indent + jName + ".attrType[" + str(i) + "] = " + ctype + ";"
            print >>fo, indent + jName + ".attrSize[" + str(i) + "] = " + str(colLen) + ";"

        print >>fo, indent + jName + ".tupleSize = " + tupleSize + ";\n"

        factOutputNum = 0
        factOutputIndex = []
        dimOutputExp = []
        factOutputPos = []
        dimPos = []

        for i in range(0, outputNum):
            newExp = ystree.__trace_to_leaf__(joinAttr.joinNode[dimNum-1], outputList[i], False)
            if newExp.table_name == joinAttr.factTables[0].table_name:
                factOutputNum +=1
                for j in range(0, len(factInputList)):
                    if newExp.column_name == factInputList[j].column_name:
                        break
                    factOutputIndex.append(j)
                    factOutputPos.append(i)

            else:
                dimOutputExp.append(newExp)
                dimPos.append(i)


        print >>fo, indent + jName + ".factOutputNum = " + str(factOutputNum) + ";"
        print >>fo, indent + jName + ".factOutputIndex = (int *) malloc(" + jName + ".factOutputNum * sizeof(int));"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".factOutputIndex);"
        print >>fo, indent + jName + ".factOutputPos = (int *) malloc(" + jName + ".factOutputNum * sizeof(int));"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".factOutputpos);"
        for i in range(0, factOutputNum):
            print >>fo, indent + jName + ".factOutputIndex[" + str(i) + "] = " + str(factOutputIndex[i]) + ";"
            print >>fo, indent + jName + ".factOutputPos[" + str(i) + "] = " + str(factOutputPos[i]) + ";"

        dimOutputTotal = outputNum - factOutputNum

        print >>fo, indent + jName + ".dimOutputTotal = " + str(dimOutputTotal) + ";"
        print >>fo, indent + jName + ".dimOutputNum = (int *) malloc( sizeof(int) * " + jName + ".dimNum);"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".dimOutputNum);"
        print >>fo, indent + jName + ".dimOutputIndex = (int **) malloc( sizeof(int*) * " + jName + ".dimNum);"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".dimOutputIndex);"
        print >>fo, indent + jName + ".dimOutputPos = (int *) malloc( sizeof(int) * " + jName + ".dimOutputTotal);"
        print >>fo, indent + "CHECK_POINTER(" + jName + ".dimOutputPos);"

        dimOutputPos = []
        for i in range(0, len(joinAttr.dimTables)):

            dimOutputNum = len(joinAttr.outIndex[i][1])
            print >>fo, indent + jName + ".dimOutputNum[" + str(i) + "] = " + str(dimOutputNum) + ";"

            if dimOutputNum >0:
                print >>fo, indent + jName + ".dimOutputIndex[" + str(i) + "] = (int *) malloc(sizeof(int) *" +str(dimOutputNum) + ");"
                print >>fo, indent + "CHECK_POINTER(" + jName + ".dimOutputIndex);"
                dimTableName = joinAttr.dimTables[i].table_name
                dimExp = []
                for exp in dimOutputExp:
                    if exp.table_name == dimTableName:
                        dimExp.append(exp)
                        pos = dimPos[dimOutputExp.index(exp)]
                        dimOutputPos.append(pos)

                for exp in dimExp:
                    tmpList = joinAttr.dimTables[i].select_list.tmp_exp_list
                    for j in range(0, len(tmpList)):
                        if tmpList[j].column_name == exp.column_name:
                            print >>fo, indent + jName + ".dimOutputIndex[" + str(i) + "][" + str(dimExp.index(exp)) + "] = " + str(j) + ";"
                            break

        for i in range(0, dimOutputTotal):
            print >>fo, indent + jName + ".dimOutputPos[" + str(i) + "] = " + str(dimOutputPos[i]) + ";"

        totalAttr = len(colList)
        print >>fo, indent + "long blockSize["+str(totalAttr) + "];"
        print >>fo, indent + "for(int i = 0; i < " + str(totalAttr) + "; i++)"
        print >>fo, indent + baseIndent + "blockSize[i] = 0;"
        print >>fo, indent + "offset = 0;\n"

        print >>fo, indent + "for(int i = 0; i < blockTotal; i++){\n"

        indent = indent_this_level + baseIndent
        print >>fo, indent + "struct tableNode *" + factName + " = (struct tableNode*)malloc(sizeof(struct tableNode));"
        print >>fo, "\t\tCHECK_POINTER(" + factName + ");"
        print >>fo, indent + factName + "->totalAttr = " + str(totalAttr) + ";"
        print >>fo, indent + factName + "->attrType = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrType);"
        print >>fo, indent + factName + "->attrSize = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrSize);"
        print >>fo, indent + factName + "->attrIndex = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrIndex);"
        print >>fo, indent + factName + "->attrTotalSize = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->attrTotalSize);"
        print >>fo, indent + factName + "->dataPos = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->dataPos);"
        print >>fo, indent + factName + "->dataFormat = (int *) malloc(sizeof(int)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->dataFormat);"
        print >>fo, indent + factName + "->content = (char **) malloc(sizeof(char *)*" + str(totalAttr) + ");"
        print >>fo, indent + "CHECK_POINTER(" + factName + "->content);"

        tupleSize = "0"
        for i in range(0,totalAttr):
            col = colList[i]
            if isinstance(col, ystree.YRawColExp):
                colType = col.column_type
                colIndex = col.column_name
                ctype = to_ctype(colType)
                colLen = type_length(joinAttr.factTables[0].table_name, colIndex, colType)
            elif isinstance(col, ystree.YConsExp):
                colType = col.cons_type
                ctype = to_ctype(colType)
                if cons_type == "INTEGER":
                    colLen = "sizeof(int)"
                elif cons_type == "FLOAT":
                    colLen = "sizeof(float)"
                else:
                    colLen = str(len(col.cons_value))
            elif isinstance(col, ystree.YFuncExp):
                print 1/0

            tupleSize += " + " + colLen
            print >>fo, indent + factName + "->attrType[" + str(i) + "] = " + ctype + ";"
            print >>fo, indent + factName + "->attrSize[" + str(i) + "] = " + colLen + ";"
            print >>fo, indent + factName + "->attrIndex[" + str(i) + "] = " + str(colIndex) + ";"

            if POS == 0:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MEM;"
            elif POS == 1:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = PINNED;"
            elif POS == 2:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = UVA;"
            elif POS == 3:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MMAP;"
            else:
                print >>fo, indent + factName + "->dataPos[" + str(i) + "] = MEM;"

        tupleSize += ";\n"
        print >>fo, indent + factName + "->tupleSize = " + tupleSize

        for i in range(0,totalAttr):
            col = colList[i] 
            colType = col.column_type
            colIndex =  col.column_name
            colLen = type_length(joinAttr.factTables[0].table_name, colIndex, colType)

            print >>fo, indent + "outFd = open(\"" + joinAttr.factTables[0].table_name + str(colIndex) + "\", O_RDONLY);"
            print >>fo, indent + "offset = i*sizeof(struct columnHeader) + blockSize["+str(i)+"];"
            print >>fo, indent + "lseek(outFd,offset,SEEK_SET);"
            print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
            print >>fo, indent + "blockSize[" + str(i) + "] += header.blockSize;"
            print >>fo, indent + "offset += sizeof(struct columnHeader);"
            print >>fo, indent + factName + "->dataFormat[" + str(i) + "] = header.format;"
            print >>fo, indent + "outSize = header.blockSize;" 
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
            print >>fo, indent + "outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);"

            if CODETYPE == 0:
                if POS == 0:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char*)malloc(outSize);\n"
                    print >>fo, indent + "CHECK_POINTER(" + factName + "->content[" + str(i) + "];"
                elif POS == 1:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void**)&"+factName+"->content["+str(i)+"],outSize));"
                elif POS == 2:
                    print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void**)&"+factName+"->content["+str(i)+"],outSize));"
                elif POS == 3:
                    print >>fo, indent + factName + "->content["+str(i)+"] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);"
                else:
                    print >>fo, indent + factName + "->content[" + str(i) + "] = (char *)memalign(256,outSize);\n"

                print >>fo, indent + "memcpy("+factName+"->content["+str(i)+"],outTable,outSize);"

            else:
                if POS == 0:
                    print >>fo, indent + factName+"->content["+str(i)+"] = (char *)memalign(256,outSize);"
                    print >>fo, indent + "memcpy("+factName+"->content["+str(i)+"],outTable,outSize);"
                elif POS == 3:
                    print >>fo, indent + factName+"->content["+str(i)+"] = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);"
                else:
                    print >>fo, indent + factName+"->content["+str(i)+"] = (char *)clCreateBuffer(context.context,CL_MEM_READ_ONLY|CL_MEM_ALLOC_HOST_PTR,outSize,NULL,0);"
                    print >>fo, indent + "clTmp = clEnqueueMapBuffer(context.queue,(cl_mem)"+factName+"->content["+str(i)+"],CL_TRUE,CL_MAP_WRITE,0,outSize,0,0,0,0);"
                    print >>fo, indent + "memcpy(clTmp,outTable,outSize);"
                    print >>fo, indent + "clEnqueueUnmapMemObject(context.queue,(cl_mem)"+factName+"->content["+str(i)+"],clTmp,0,0,0);"


            print >>fo, indent + "munmap(outTable,outSize);"
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
            print >>fo, indent + "close(outFd);"
            print >>fo, indent + factName + "->attrTotalSize[" + str(i) + "] = outSize;"

        print >>fo, indent + factName + "->tupleNum = header.tupleNum;"

        if joinAttr.factTables[0].where_condition is not None:
            hasWhere = 1
            whereExp = joinAttr.factTables[0].where_condition.where_condition_exp
            whereList = []
            relList = []
            conList = []

            get_where_attr(whereExp,whereList,relList,conList)
            newWhereList = []
            whereLen = count_whereList(whereList, newWhereList)
            nested = count_whereNested(whereExp)

            if nested !=0:
                print "Not supported yet: the where expression is too complicated"
                print 1/0

            relName = joinAttr.factTables[0].table_name.lower() + "Rel"
            print >>fo, indent + "struct scanNode " + relName + ";"
            print >>fo, indent + relName + ".tn = " + factName + ";"
            print >>fo, indent + relName + ".hasWhere = 1;"
            print >>fo, indent + relName + ".outputNum = " + str(len(selectList)) + ";"
            print >>fo, indent + relName + ".whereAttrNum = " + str(whereLen) + ";"
            print >>fo, indent + relName + ".whereIndex = (int *)malloc(sizeof(int)*" + str(whereLen) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".whereIndex);"
            print >>fo, indent + relName + ".outputIndex = (int *)malloc(sizeof(int)*" + str(len(selectList)) + ");"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".outputIndex);"

            if keepInGpu == 0:
                print >>fo, indent + relName + ".keepInGpu = 0;"
            else:
                print >>fo, indent + relName + ".keepInGpu = 1;"

            for i in range(0,len(newWhereList)):
                colIndex = int(newWhereList[i].column_name)
                print >>fo, indent + relName + ".whereIndex["+str(i) + "] = " + str(colIndex) + ";"

            for i in range(0,len(selectList)):
                colIndex = selectList[i].column_name
                outputIndex = indexList.index(colIndex)
                print >>fo, indent + relName + ".outputIndex[" + str(i) + " ] = " + str(outputIndex) + ";"

            print >>fo, indent + relName + ".filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));"
            print >>fo, indent + "CHECK_POINTER(" + relName + ".filter);"

            print >>fo, indent + "(" + relName + ".filter)->nested = 0;"
            print >>fo, indent + "(" + relName + ".filter)->expNum = " + str(len(whereList)) + ";"
            print >>fo, indent + "(" + relName + ".filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *" + str(len(whereList)) + ");"
            print >>fo, indent + "CHECK_POINTER((" + relName + ".filter)->exp);"

            if joinAttr.factTables[0].where_condition.where_condition_exp.func_name in ["AND","OR"]:
                print >>fo, indent + "(" + relName + ".filter)->andOr = " + joinAttr.factTables[0].where_condition.where_condition_exp.func_name + ";"

            else:
                print >>fo, indent + "(" + relName + ".filter)->andOr = EXP;"

            for i in range(0,len(whereList)):
                colIndex = -1
                for j in range(0,len(newWhereList)):
                    if newWhereList[j].compare(whereList[i]) is True:
                        colIndex = j
                        break

                if colIndex <0:
                    print 1/0

                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].index    = " + str(colIndex) + ";"
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + ";" 
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = MEM";

                colType = whereList[i].column_type
                ctype = to_ctype(colType)

                if ctype == "INT":
                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "int tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(int));"
                    print >>fo, indent + "}"

                elif ctype == "FLOAT":

                    print >>fo, indent + "{"
                    print >>fo, indent + baseIndent + "float tmp = " + conList[i] + ";"
                    print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp,sizeof(float));"
                    print >>fo, indent + "}"
                    print 1/0
                else:
                    print >>fo, indent + "strcpy((" + relName + ".filter)->exp[" + str(i) + "].content," + conList[i] + ");\n"

            if CODETYPE == 0:
                print >>fo, indent + "struct tableNode * " + resName + " = tableScan(&" + relName + ", &pp);"
            else:
                print >>fo, indent + "struct tableNode * " + resName + " = tableScan(&" + relName + ", &context,&pp);"

            if selectOnly == 0:
                print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
                print >>fo, indent + "freeScan(&" + relName + ");\n"

                if CODETYPE == 1:
                    print >>fo, indent + "clFinish(context.queue);"
                    print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
                    print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

        else:
            hasWhere = 0
            print >>fo, indent + "struct tableNode * " + resName + " = " + factName + ";"

        print >>fo, indent + jName + ".factTable = " + resName + ";"

        if CODETYPE == 0:
            print >>fo, indent + "struct tableNode *join1 = inviJoin(&" + jName + ", &pp);"
        else:
            print >>fo, indent + "struct tableNode *join1 = inviJoin(&" + jName + ", &context,&pp);"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
        print >>fo, indent + "freeTable(" + resName + ");"

        if CODETYPE == 1:
            print >>fo, indent + "clFinish(context.queue);"
            print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
            print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

        print >>fo, indent + "if(blockTotal != 1){"

        indent = indent_this_level + 2 * baseIndent
        if CODETYPE == 0:
            print >>fo, indent + "mergeIntoTable(" + resultNode + ",join1,&pp);"
        else:
            print >>fo, indent + "mergeIntoTable(" + resultNode + ",join1,&context,&pp);"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
        print >>fo, indent + "freeTable(join1);"
        if CODETYPE == 1:
            print >>fo, indent + "clFinish(context.queue);"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskEnd);"
        print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
        print >>fo, ((lvl + 1) * baseIndent) + "}else"
        print >>fo, indent + resultNode + "=join1;"

        indent = indent_this_level
        print >>fo, indent + "}\n"


    if len(aggNode) >0 :
        """
        Generate codes for aggregation node.
        """

        gb_exp_list = aggNode[0].group_by_clause.groupby_exp_list
        select_list = aggNode[0].select_list.tmp_exp_list
        selectLen = len(select_list)
        gbLen = len(gb_exp_list)

        indent = indent_this_level
        print >>fo, indent + "struct groupByNode * gbNode = (struct groupByNode *) malloc(sizeof(struct groupByNode));"
        print >>fo, indent + "CHECK_POINTER(gbNode);"
        print >>fo, indent + "gbNode->table = " +resultNode +";"
        print >>fo, indent + "gbNode->groupByColNum = " + str(gbLen) + ";"
        print >>fo, indent + "gbNode->groupByIndex = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->groupByIndex);"
        print >>fo, indent + "gbNode->groupByType = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->groupByType);"
        print >>fo, indent + "gbNode->groupBySize = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->groupBySize);"

        for i in range(0,gbLen):
            exp = gb_exp_list[i]
            if isinstance(exp, ystree.YRawColExp):
                print >>fo, indent + "gbNode->groupByIndex[" + str(i) + "] = " + str(exp.column_name) + ";"
                print >>fo, indent + "gbNode->groupByType[" + str(i) + "] = gbNode->table->attrType[" + str(exp.column_name) + "];" 
                print >>fo, indent + "gbNode->groupBySize[" + str(i) + "] = gbNode->table->attrSize[" + str(exp.column_name) + "];" 
            elif isinstance(exp, ystree.YConsExp):
                print >>fo, indent + "gbNode->groupByIndex[" + str(i) + "] = -1;" 
                print >>fo, indent + "gbNode->groupByType[" + str(i) + "] = INT;" 
                print >>fo, indent + "gbNode->groupBySize[" + str(i) + "] = sizeof(int);" 
            else:
                print 1/0

        print >>fo, indent + "gbNode->outputAttrNum = " + str(selectLen) + ";"
        print >>fo, indent + "gbNode->attrType = (int *) malloc(sizeof(int) *" + str(selectLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->attrType);"
        print >>fo, indent + "gbNode->attrSize = (int *) malloc(sizeof(int) *" + str(selectLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->attrSize);"
        print >>fo, indent + "gbNode->tupleSize = 0;"
        print >>fo, indent + "gbNode->gbExp = (struct groupByExp *) malloc(sizeof(struct groupByExp) * " + str(selectLen) + ");"
        print >>fo, indent + "CHECK_POINTER(gbNode->gbExp);"

        for i in range(0,selectLen):
            exp = select_list[i]
            if isinstance(exp, ystree.YFuncExp):

                print >>fo, indent + "gbNode->tupleSize += sizeof(float);"
                print >>fo, indent + "gbNode->attrType[" + str(i) + "] = FLOAT;"
                print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(float);"
                print >>fo, indent + "gbNode->gbExp["+str(i)+"].func = " + exp.func_name + ";"
                para = exp.parameter_list[0]
                mathFunc = mathExp()
                mathFunc.addOp(para)
                prefix = indent + "gbNode->gbExp[" + str(i) + "].exp"
                printMathFunc(fo,prefix, mathFunc)

            elif isinstance(exp, ystree.YRawColExp):
                colIndex = exp.column_name
                print >>fo, indent + "gbNode->attrType[" + str(i) + "] = " + resultNode + "->attrType[" + str(colIndex) + "];"
                print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = " + resultNode + "->attrSize[" + str(colIndex) + "];"
                print >>fo, indent + "gbNode->tupleSize += "+resultNode + "->attrSize[" + str(colIndex) + "];"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].func = NOOP;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.op = NOOP;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.exp = NULL;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opNum = 1;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opType = COLUMN;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opValue = " + str(exp.column_name) + ";"

            else:
                if exp.cons_type == "INTEGER":
                    print >>fo, indent + "gbNode->attrType[" + str(i) + "] = INT;"
                    print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(int);"
                    print >>fo, indent + "gbNode->tupleSize += sizeof(int);"
                elif exp.cons_type == "FLOAT":
                    print >>fo, indent + "gbNode->attrType[" + str(i) + "] = FLOAT;"
                    print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(float);"
                    print >>fo, indent + "gbNode->tupleSize += sizeof(float);"
                else:
                    print 1/0

                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].func = NOOP;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.op = NOOP;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.exp = NULL;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opNum = 1;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opType = CONS;"
                print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opValue = " + str(exp.cons_value) + ";"

        resultNode = "gbResult"

        if CODETYPE == 0:
            print >>fo, indent + "struct tableNode * " + resultNode + " = groupBy(gbNode, &pp);"
        else:
            print >>fo, indent + "struct tableNode * " + resultNode + " = groupBy(gbNode, &context,&pp);"
            print >>fo, indent + "freeGroupByNode(gbNode);\n"


    if len(orderbyNode) > 0 :
        """
        Generate codes for order by node.
        """

        indent = indent_this_level
        orderby_exp_list = orderbyNode[0].order_by_clause.orderby_exp_list
        odLen = len(orderby_exp_list)
        print >>fo, indent + "struct orderByNode * odNode = (struct orderByNode *) malloc(sizeof(struct orderByNode));"
        print >>fo, indent + "CHECK_POINTER(odNode);"
        print >>fo, indent + "odNode->table = " +resultNode +";"
        print >>fo, indent + "odNode->orderByNum = " + str(odLen) + ";"
        print >>fo, indent + "odNode->orderBySeq = (int *) malloc(sizeof(int) * odNode->orderByNum);"
        print >>fo, indent + "CHECK_POINTER(odNode->orderBySeq);"
        print >>fo, indent + "odNode->orderByIndex = (int *) malloc(sizeof(int) * odNode->orderByNum);"
        print >>fo, indent + "CHECK_POINTER(odNode->orderByIndex);"

        for i in range(0,odLen):
            seq = orderbyNode[0].order_by_clause.order_indicator_list[i]
            if seq == "ASC":
                print >>fo, indent + "odNode->orderBySeq[" + str(i) + "] = ASC;"
            else:
                print >>fo, indent + "odNode->orderBySeq[" + str(i) + "] = DESC;"

            print >>fo, indent + "odNode->orderByIndex[" + str(i) + "] = " + str(orderby_exp_list[i].column_name) + ";"

        resultNode = "odResult"

        if CODETYPE == 0:
            print >>fo, indent + "struct tableNode * " + resultNode + " = orderBy(odNode,&pp);"
        else:
            print >>fo, indent + "struct tableNode * " + resultNode + " = orderBy(odNode, &context,&pp);"

        print >>fo, indent + "freeOrderByNode(odNode);\n"

    indent = indent_this_level
    print >>fo, indent + "struct materializeNode mn;"
    print >>fo, indent + "mn.table = "+resultNode + ";"
    if CODETYPE == 0:
        print >>fo, indent + "char *final = materializeCol(&mn, &pp);"
    else:
        print >>fo, indent + "materializeCol(&mn, &context,&pp);"
        print >>fo, indent + "freeTable(" + resultNode + ");\n"

    if CODETYPE == 1:
        print >>fo, indent + "clReleaseCommandQueue(context.queue);"
        print >>fo, indent + "clReleaseContext(context.context);"
        print >>fo, indent + "clReleaseProgram(context.program);\n"


"""
gpudb_code_gen: entry point for code generation.
"""

def gpudb_code_gen(argv):
    pwd = os.getcwd()
    resultDir = "./src"
    utilityDir = "./utility"

    if CODETYPE == 0:
        codeDir = "./cuda"
    else:
        codeDir = "./opencl"

    includeDir = "./include"
    schemaFile = None 

    if len(sys.argv) == 3:
        tree_node = ystree.ysmart_tree_gen(argv[1],argv[2])

    elif len(sys.argv) == 2:
        schemaFile = ystree.ysmart_get_schema(argv[1])

    if len(sys.argv) == 3 and tree_node is None:
        exit(-1)

    if os.path.exists(resultDir) is False:
        os.makedirs(resultDir)

    os.chdir(resultDir)
    if os.path.exists(codeDir) is False:
        os.makedirs(codeDir)

    if os.path.exists(includeDir) is False:
        os.makedirs(includeDir)

    os.chdir(includeDir)

    generate_schema_file()

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(utilityDir)

    generate_loader()
    if SOA == 1:
        generate_soa()

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(codeDir)

    if len(sys.argv) == 3:
        generate_code(tree_node)

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(utilityDir)

    if schemaFile is not None:
        metaFile = open(".metadata",'wb')
        pickle.dump(schemaFile, metaFile)
        metaFile.close()

    os.chdir(pwd)

