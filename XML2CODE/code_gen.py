#! /usr/bin/python
"""
   Copyright (c) 2012-2013 The Ohio State University.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

import sys
import commands
import os.path
import copy
import ystree
import correlation
import config
import pickle

schema = None
keepInGpu = 1
baseIndent = " " * 4
optimization = None

merge = lambda l1, l2: [ (l1[i], l2[i]) for i in range(0, min(len(l1), len(l2))) ]
unmerge = lambda l: ( [ l[i][0] for i in range(0, len(l)) ], [ l[i][1] for i in range(0, len(l)) ] )
loaded_table_list = {}

"""
Get the value of the configurable variables from config.py
"""

joinType = config.joinType
POS = config.POS
SOA = config.SOA
CODETYPE = config.CODETYPE

PID = config.PID
DTYPE = config.DTYPE

"""
Generate C style declaration of a given column.
The name of the variable is the lower cased column name.
"""

def column_to_variable(col):
    res = ""
    if col.column_type in ["INTEGER","DATE"]:
        res = "int " + col.column_name.lower() + ";"
    elif col.column_type in ["DECIMAL"]:
        res = "float " + col.column_name.lower() + ";"
    elif col.column_type in ["TEXT"]:
        res = "char " + col.column_name.lower() + "[" + str(col.column_others) + "];"

    return res

"""
Generate schema.h file from the defined table schema.
"""

def generate_schema_file():
    global schema

    schema = ystree.global_table_dict
    fo = open("schema.h","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#ifndef __SCHEMA_H__"
    print >>fo, "#define __SCHEMA_H__"
    for tn in schema.keys():
        print >>fo, "\tstruct " + tn.lower() + " {"
        for col in schema[tn].column_list:
            print >>fo, "\t\t" + column_to_variable(col)
        print >>fo, "\t};\n"

    print >>fo, "#endif"
    fo.close()

"""
generate_soa generates a python script that will help transform
data from AOS to SOA. This is only for comparing the performance
of SOA with AOS.
"""

def generate_soa():

    global schema

    schema = ystree.global_table_dict

    fo = open("soa.py","w")

    print >>fo, "#! /usr/bin/python"
    print >>fo, "import os\n"

    print >>fo, "cmd = \"\""
    for tn in schema.keys():
        attrLen = len(schema[tn].column_list)

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            if col.column_type == "TEXT":
                print >>fo, "cmd = \"./soa " + tn + str(i) + " " + str(col.column_others) + "\""
                print >>fo, "os.system(cmd)"

    fo.close()
    os.system("chmod +x ./soa.py")

"""
generate_loader will generate the load.c which will transform
the row-stored text raw data into column-stored binary data.
"""

def generate_loader():
    global schema

    schema = ystree.global_table_dict

    fo = open("load.c","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#define _FILE_OFFSET_BITS       64"
    print >>fo, "#define _LARGEFILE_SOURCE"
    print >>fo, "#include <stdio.h>"
    print >>fo, "#include <stdlib.h>"
    print >>fo, "#include <error.h>"
    print >>fo, "#include <unistd.h>"
    print >>fo, "#include <string.h>"
    print >>fo, "#include <getopt.h>"
    print >>fo, "#include <linux/limits.h>"
    print >>fo, "#include \"../include/schema.h\""
    print >>fo, "#include \"../include/common.h\""
    print >>fo, "#define CHECK_POINTER(p) do {\\"
    print >>fo, "\tif(p == NULL){   \\"
    print >>fo, "\t\tperror(\"Failed to allocate host memory\");    \\"
    print >>fo, "\t\texit(-1);  \\"
    print >>fo, "\t}} while(0)"

    print >>fo, "static char delimiter = '|';"

    for tn in schema.keys():
        attrLen = len(schema[tn].column_list)

        print >>fo, "void " + tn.lower() + " (FILE *fp, char *outName){\n"

        print >>fo, "\tstruct " + tn.lower() + " tmp;"
        print >>fo, "\tchar data [1024] = {0};"
        print >>fo, "\tchar buf[1024] = {0};"
        print >>fo, "\tint count = 0, i = 0,prev = 0;"
        print >>fo, "\tlong tupleCount =0, tupleRemain = 0, tupleUnit = 0;"
        print >>fo, "\tFILE * out[" + str(attrLen) + "];\n"

        print >>fo, "\tfor(i=0;i<" + str(attrLen) + ";i++){"
        print >>fo, "\t\tchar path[PATH_MAX] = {0};"
        print >>fo, "\t\tsprintf(path,\"%s%d\",outName,i);"
        print >>fo, "\t\tout[i] = fopen(path, \"w\");"
        print >>fo, "\t\tif(!out[i]){"
        print >>fo, "\t\t\tprintf(\"Failed to open %s\\n\",path);"
        print >>fo, "\t\t\texit(-1);"
        print >>fo, "\t\t}"
        print >>fo, "\t}\n"

        print >>fo, "\tstruct columnHeader header;"
        print >>fo, "\tlong tupleNum = 0;"
        print >>fo, "\twhile(fgets(buf,sizeof(buf),fp) !=NULL)"
        print >>fo, "\t\ttupleNum ++;\n"
        print >>fo, "\theader.totalTupleNum = tupleNum;"
        print >>fo, "\ttupleRemain = tupleNum;"

        print >>fo, "\tif(tupleNum > BLOCKNUM)"
        print >>fo, "\t\ttupleUnit = BLOCKNUM;"
        print >>fo, "\telse"
        print >>fo, "\t\ttupleUnit = tupleNum;"

        print >>fo, "\theader.tupleNum = tupleUnit;"
        print >>fo, "\theader.format = UNCOMPRESSED;"
        print >>fo, "\theader.blockId = 0;"
        print >>fo, "\theader.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;"

        print >>fo, "\tfseek(fp,0,SEEK_SET);"

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            if col.column_type == "INTEGER" or col.column_type == "DATE":
                print >>fo, "\theader.blockSize = header.tupleNum * sizeof(int);"
            elif col.column_type == "DECIMAL":
                print >>fo, "\theader.blockSize = header.tupleNum * sizeof(float);"
            elif col.column_type == "TEXT":
                print >>fo, "\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"

            print >>fo, "\tfwrite(&header, sizeof(struct columnHeader), 1, out[" + str(i) + "]);"

        print >>fo, "\twhile(fgets(buf,sizeof(buf),fp)!= NULL){"

        print >>fo, "\t\tint writeHeader = 0;"
        print >>fo, "\t\ttupleCount ++;"
        print >>fo, "\t\tif(tupleCount > BLOCKNUM){"
        print >>fo, "\t\t\ttupleCount = 1;"
        print >>fo, "\t\t\ttupleRemain -= BLOCKNUM;"
        print >>fo, "\t\t\tif (tupleRemain > BLOCKNUM)"
        print >>fo, "\t\t\t\ttupleUnit = BLOCKNUM;"
        print >>fo, "\t\t\telse"
        print >>fo, "\t\t\t\ttupleUnit = tupleRemain;"
        print >>fo, "\t\t\theader.tupleNum = tupleUnit;"
        print >>fo, "\t\t\theader.blockId ++;"
        print >>fo, "\t\t\twriteHeader = 1;"
        print >>fo, "\t\t}"

        print >>fo, "\t\tfor(i = 0, prev = 0,count=0; buf[i] !='\\n';i++){"
        print >>fo, "\t\t\tif (buf[i] == delimiter){"
        print >>fo, "\t\t\t\tmemset(data,0,sizeof(data));"
        print >>fo, "\t\t\t\tstrncpy(data,buf+prev,i-prev);"
        print >>fo, "\t\t\t\tprev = i+1;"
        print >>fo, "\t\t\t\tswitch(count){"

        for i in range(0,attrLen):
            col = schema[tn].column_list[i]
            print >>fo, "\t\t\t\t\t case " + str(i) + ":"

            if col.column_type == "INTEGER" or col.column_type == "DATE":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * sizeof(int);"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\ttmp."+str(col.column_name.lower()) + " = strtol(data,NULL,10);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(int),1,out["+str(i) + "]);"
            elif col.column_type == "DECIMAL":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * sizeof(float);"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\ttmp."+str(col.column_name.lower()) + " = atof(data);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(float),1,out["+str(i) + "]);"
            elif col.column_type == "TEXT":
                print >>fo, "\t\t\t\t\t\tif(writeHeader == 1){"
                print >>fo, "\t\t\t\t\t\t\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"
                print >>fo, "\t\t\t\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(i) + "]);"
                print >>fo, "\t\t\t\t\t\t}"
                print >>fo, "\t\t\t\t\t\tstrcpy(tmp." + str(col.column_name.lower()) + ",data);"
                print >>fo, "\t\t\t\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(tmp." +str(col.column_name.lower()) + "), 1, out[" + str(i) + "]);"

            print >>fo, "\t\t\t\t\t\tbreak;"

        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tcount++;"

        print >>fo, "\t\t\t}"
        print >>fo, "\t\t}"

        print >>fo, "\t\tif(count == " + str(attrLen-1) + "){"

        col = schema[tn].column_list[attrLen-1]
        if col.column_type == "INTEGER" or col.column_type == "DATE":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * sizeof(int);"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tmemset(data,0,sizeof(data));"
            print >>fo, "\t\t\tstrncpy(data,buf+prev,i-prev);"
            print >>fo, "\t\t\ttmp."+str(col.column_name.lower()) + " = strtol(data,NULL,10);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(int),1,out["+str(attrLen-1) + "]);"
        elif col.column_type == "DECIMAL":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * sizeof(float);"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tmemset(data,0,sizeof(data));"
            print >>fo, "\t\t\tstrncpy(data,buf+prev,i-prev);"
            print >>fo, "\t\t\ttmp."+str(col.column_name.lower()) + " = atof(data);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(float),1,out["+str(i) + "]);"
        elif col.column_type == "TEXT":
            print >>fo, "\t\t\tif(writeHeader == 1){"
            print >>fo, "\t\t\t\theader.blockSize = header.tupleNum * " + str(col.column_others) + ";"
            print >>fo, "\t\t\t\tfwrite(&header,sizeof(struct columnHeader),1,out[" + str(attrLen-1) + "]);"
            print >>fo, "\t\t\t}"
            print >>fo, "\t\t\tstrncpy(tmp." + str(col.column_name.lower()) + ",buf+prev,i-prev);"
            print >>fo, "\t\t\tfwrite(&(tmp." + str(col.column_name.lower()) + "),sizeof(tmp." +str(col.column_name.lower()) + "), 1, out[" + str(attrLen-1) + "]);"

        print >>fo, "\t\t}"


        print >>fo, "\t}\n" ### end of reading from input file

        print >>fo, "\tfor(i=0;i<" + str(attrLen) + ";i++){"
        print >>fo, "\t\tfclose(out[i]);"
        print >>fo, "\t}"

        print >>fo, "\n}\n"

    print >>fo, "int main(int argc, char ** argv){\n"
    print >>fo, "\tFILE * in = NULL, *out = NULL;"
    print >>fo, "\tint table;"
    print >>fo, "\tint setPath = 0;"
    print >>fo, "\tchar path[PATH_MAX];"
    print >>fo, "\tchar cwd[PATH_MAX];"
    print >>fo, "\t"
    print >>fo, "\tint long_index;"

    print >>fo, "\tstruct option long_options[] = {"
    for i in range(0, len(schema.keys())):
        print >>fo, "\t\t{\"" + schema.keys()[i].lower()+ "\",required_argument,0,'" + str(i) + "'},"

    print >>fo, "\t\t{\"delimiter\",required_argument,0,'" +str(i+1) + "'},"
    print >>fo, "\t\t{\"datadir\",required_argument,0,'" +str(i+2) + "'}"
    print >>fo, "\t};\n"

    print >>fo, "\twhile((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, "\t\tswitch(table){"
    print >>fo, "\t\t\tcase '" + str(i + 2) + "':"
    print >>fo, "\t\t\t\tsetPath = 1;"
    print >>fo, "\t\t\t\tstrcpy(path,optarg);"
    print >>fo, "\t\t\t\tbreak;"
    print >>fo, "\t\t}"
    print >>fo, "\t}\n"

    print >>fo, "\toptind=1;\n"
    print >>fo, "\tgetcwd(cwd,PATH_MAX);"

    print >>fo, "\twhile((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, "\t\tswitch(table){"
    for i in range(0, len(schema.keys())):
        print >>fo, "\t\t\tcase '" + str(i) + "':"
        print >>fo, "\t\t\t\tin = fopen(optarg,\"r\");"
        print >>fo, "\t\t\t\tif(!in){"
        print >>fo, "\t\t\t\t\tprintf(\"Failed to open %s\\n\",optarg);"
        print >>fo, "\t\t\t\t\texit(-1);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tif (setPath == 1){"
        print >>fo, "\t\t\t\t\tchdir(path);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\t" + schema.keys()[i].lower() + "(in,\"" + schema.keys()[i] + "\");"
        print >>fo, "\t\t\t\tif (setPath == 1){"
        print >>fo, "\t\t\t\t\tchdir(cwd);"
        print >>fo, "\t\t\t\t}"
        print >>fo, "\t\t\t\tfclose(in);"
        print >>fo, "\t\t\t\tbreak;"

    print >>fo, "\t\t\tcase '" + str(i+1) + "':"
    print >>fo, "\t\t\t\tdelimiter = optarg[0];"
    print >>fo, "\t\t\t\tbreak;"
    print >>fo, "\t\t}"
    print >>fo, "\t}\n"

    print >>fo, "\treturn 0;"

    print >>fo, "}\n"

    fo.close()

class columnAttr(object):
    type = None
    size = None

    def __init__ (self):
        self.type = ""
        self.size = 0

class JoinTranslation(object):
    dimTables = None
    factTables = None
    joinNode = None
    dimIndex = None
    factIndex = None
    outIndex = None
    outAttr = None
    outPos = None

    def __init__ (self):
        self.dimTables = []
        self.factTables = []
        self.joinNode = []
        self.dimIndex = []
        self.factIndex = []
        self.outIndex = []
        self.outAttr = []
        self.outPos = []

    def __repr__(self):
        print "dimTables: ", self.dimTables
        print "factTables: ", self.factTables
        print "joinNode: ", self.joinNode
        print "dimIndex: ", self.dimIndex
        print "factIndex: ", self.factIndex
        print "outIndex: ", self.outIndex
        print "outAttr: ", self.outAttr
        print "outPos: ", self.outPos

def __get_gb_exp__(exp,tmp_list):
    if not isinstance(exp,ystree.YFuncExp):
        return

    if exp.func_name in ["SUM","AVG","COUNT","MAX","MIN"]:
        tmp_list.append(exp)
    else:
        for x in exp.parameter_list:
            __get_gb_exp__(x,tmp_list)


def get_gbexp_list(exp_list,gb_exp_list):
    for exp in exp_list:
        if not isinstance(exp,ystree.YFuncExp):
            continue
        tmp_list = []
        __get_gb_exp__(exp,tmp_list)
        for tmp in tmp_list:
            tmp_bool = False
            for gb_exp in gb_exp_list:
                if tmp.compare(gb_exp) is True:
                    tmp_bool = True
                    break
            if tmp_bool is False:
                gb_exp_list.append(tmp)

"""
get_tables() gets the translation information for join, agg and order by nodes.
Currently we only support star schema queries.
We assume that the dimTable is always the right child of the join node.
"""

def get_tables(tree, joinAttr, aggNode, orderbyNode):

    # The leaf is the fact table
    if isinstance(tree, ystree.TableNode):
        joinAttr.factTables.append(tree)
        return

    # copy into orderbyNode
    elif isinstance(tree, ystree.OrderByNode):
        obNode = copy.deepcopy(tree)
        orderbyNode.append(obNode)
        get_tables(tree.child, joinAttr, aggNode, orderbyNode)

    # copy into aggNode
    elif isinstance(tree, ystree.GroupByNode):

        gbNode = copy.deepcopy(tree)
        aggNode.append(gbNode)
        get_tables(tree.child, joinAttr, aggNode, orderbyNode)

    elif isinstance(tree, ystree.TwoJoinNode):

        leftIndex = []
        rightIndex = []
        leftAttr = []
        rightAttr = []
        leftPos = []
        rightPos = []

        # copy into joinAttr
        newNode = copy.deepcopy(tree)
        joinAttr.joinNode.insert(0,newNode)

        for exp in tree.select_list.tmp_exp_list:

            index = tree.select_list.tmp_exp_list.index(exp)
            if isinstance(exp,ystree.YRawColExp):
                colAttr = columnAttr()
                colAttr.type = exp.column_type
                if exp.table_name == "LEFT":

                    if joinType == 0:
                        leftIndex.append(exp.column_name)

                    elif joinType == 1:
                        newExp = ystree.__trace_to_leaf__(tree,exp,False) # Get the real table name
                        leftIndex.append(newExp.column_name)

                    leftAttr.append(colAttr)
                    leftPos.append(index)

                elif exp.table_name == "RIGHT":

                    if joinType == 0:
                        rightIndex.append(exp.column_name)

                    elif joinType == 1:
                        newExp = ystree.__trace_to_leaf__(tree,exp,False)
                        rightIndex.append(newExp.column_name)

                    rightAttr.append(colAttr)
                    rightPos.append(index)

        # index: column id in the original table
        outList= []
        outList.append(leftIndex)
        outList.append(rightIndex)

        # attr: column name in the original table
        outAttr = []
        outAttr.append(leftAttr)
        outAttr.append(rightAttr)

        # pos: column id in the join table
        outPos = []
        outPos.append(leftPos)
        outPos.append(rightPos)

        joinAttr.outIndex.insert(0,outList)
        joinAttr.outAttr.insert(0, outAttr)
        joinAttr.outPos.insert(0, outPos)

        pkList = tree.get_pk()
        # def exp_list_to_str(exp_list):
        #     return map(lambda exp: exp.evaluate(), exp_list)
        # print "pkList[0]: ", exp_list_to_str(pkList[0])
        # print "pkList[1]: ", exp_list_to_str(pkList[1])

        if (len(pkList[0]) != len(pkList[1])):
            print 1/0

        if joinType == 0:
            for exp in pkList[0]:
                colIndex = 0
                if isinstance(tree.left_child, ystree.TableNode):
                    colIndex = -1
                    for tmp in tree.left_child.select_list.tmp_exp_list:
                        if exp.column_name == tmp.column_name:
                            colIndex = tree.left_child.select_list.tmp_exp_list.index(tmp)
                            break
                    if colIndex == -1:
                        print 1/0
                else:
                    colIndex = exp.column_name

        elif joinType == 1:
            for exp in pkList[0]:
                newExp = ystree.__trace_to_leaf__(tree,exp,True)
                colIndex = newExp.column_name

        joinAttr.factIndex.insert(0, colIndex)

        for exp in pkList[1]:
            colIndex = 0
            if isinstance(tree.right_child, ystree.TableNode):
                colIndex = -1
                for tmp in tree.right_child.select_list.tmp_exp_list:
                    if exp.column_name == tmp.column_name:
                        colIndex = tree.right_child.select_list.tmp_exp_list.index(tmp)
                        break
                if colIndex == -1:
                    print 1/0
            else:
                colIndex = exp.column_name
            joinAttr.dimIndex.insert(0, colIndex)

        if isinstance(tree.right_child, ystree.TableNode):
            joinAttr.dimTables.insert(0, tree.right_child)

        get_tables(tree.left_child, joinAttr, aggNode, orderbyNode)


"""
Translate the type defined in the schema into the supported
type in the translated c program.
Currently only three types are supported:
    INT, FLOAT and STRING.
"""

def to_ctype(colType):

    if colType in ["INTEGER","DATE"]:
        return "INT";
    elif colType in ["TEXT"]:
        return "STRING"
    elif colType in ["DECIMAL"]:
        return "FLOAT"

"""
Get the length of a given column.
"""

def type_length(tn, colIndex, colType):
    if colType in ["INTEGER", "DATE"]:
        return "sizeof(int)"
    elif colType in ["TEXT"]:
        colLen = schema[tn].column_list[colIndex].column_others
        return str(colLen)
    elif colType in ["DECIMAL"]:
        return "sizeof(float)"

"""
Get the exp information from the where expresion.
"""

def get_where_attr(exp, whereList, relList, conList):
    if isinstance(exp, ystree.YFuncExp):
        if exp.func_name in ["AND", "OR"]:
            for x in exp.parameter_list:
                if isinstance(x, ystree.YFuncExp):
                    get_where_attr(x,whereList, relList, conList)
                elif isinstance(x, ystree.YRawColExp):
                    whereList.append(x)
        else:
            relList.append(exp.func_name)
            for x in exp.parameter_list:
                if isinstance(x, ystree.YRawColExp):
                    whereList.append(x)
                elif isinstance(x, ystree.YConsExp):
                    if x.ref_col != None:
                        conList.append(x.ref_col)
                    else:
                        conList.append(x.cons_value)
                elif isinstance(x, ystree.YFuncExp) and (x.func_name == "SUBQ" or x.func_name == "LIST"):
                    conList.append(x)

    elif isinstance(exp, ystree.YRawColExp):
        whereList.append(exp)


"""
Generate a new where list where no duplate columns exist.
Return the number of columns in the new list.
"""

def count_whereList(wlist, tlist):

    for col in wlist:
        colExist = False
        for x in tlist:
            if x.compare(col) is True:
                colExist = True
                break
        if colExist is False:
            tlist.append(col)

    return len(tlist)

"""
count the nested level of the where condition.
"""

def count_whereNested(exp):
    count = 0

    if isinstance(exp, ystree.YFuncExp):
        if exp.func_name in ["AND", "OR"]:
            for x in exp.parameter_list:
                max = 0
                if isinstance(x,ystree.YFuncExp) and x.func_name in ["AND","OR"]:
                    max +=1
                    max += count_whereNest(x)
                    if max > count:
                        count = max

    return count

class mathExp:
    opName = None
    leftOp = None
    rightOp = None
    value = None

    def __init__(self):
        self.opName = None
        self.leftOp = None
        self.rightOp = None
        self.value = None

    def addOp(self, exp):

        if isinstance(exp,ystree.YRawColExp):
            self.opName = "COLUMN_" + exp.column_type
            self.value = exp.column_name
        elif isinstance(exp,ystree.YConsExp):
            self.opName = "CONS"
            self.value = exp.cons_value
        elif isinstance(exp,ystree.YFuncExp):
            self.opName = exp.func_name
            leftExp = exp.parameter_list[0]
            rightExp = exp.parameter_list[1]

            self.leftOp = mathExp()
            self.rightOp = mathExp()
            self.leftOp.addOp(leftExp)
            self.rightOp.addOp(rightExp)

### print the mathExp in c

def printMathFunc(fo,prefix, mathFunc):

    if mathFunc.opName == "COLUMN":
        print >>fo, prefix + ".op = NOOP;"
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = COLUMN;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    elif mathFunc.opName == "COLUMN_DECIMAL":
        print >>fo, prefix + ".op = NOOP;"
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = COLUMN_DECIMAL;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    elif mathFunc.opName == "COLUMN_INTEGER":
        print >>fo, prefix + ".op = NOOP;"
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = COLUMN_INTEGER;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    elif mathFunc.opName == "CONS":
        print >>fo, prefix + ".op = NOOP;"
        print >>fo, prefix + ".opNum = 1;"
        print >>fo, prefix + ".exp = 0;"
        print >>fo, prefix + ".opType = CONS;"
        print >>fo, prefix + ".opValue = " + str(mathFunc.value) + ";"
    else:
        print >>fo, prefix + ".op = " + mathFunc.opName + ";"
        print >>fo, prefix + ".opNum = 2;"
        print >>fo, prefix + ".exp = (long) malloc(sizeof(struct mathExp) * 2);"
        prefix1 = "((struct mathExp *)" + prefix + ".exp)[0]"
        prefix2 = "((struct mathExp *)"+ prefix + ".exp)[1]"
        printMathFunc(fo,prefix1,mathFunc.leftOp)
        printMathFunc(fo,prefix2,mathFunc.rightOp)

"""
generate_col_list gets all the columns that will be scannned for a given table node.
@indexList stores the index of each column.
@colList stores the columnExp for each column.
"""

def generate_col_list(tn, indexList, colList):

    for col in tn.select_list.tmp_exp_list:
        if col.column_name not in indexList:
            indexList.append(col.column_name)
            colList.append(col)
 
    if tn.where_condition is not None:
        whereList = []
        relList = []
        conList = []
        get_where_attr(tn.where_condition.where_condition_exp,whereList,relList,conList)
        for col in whereList:
            if col.column_name not in indexList:
                indexList.append(col.column_name)
                colList.append(col)
        for con in conList:
            if isinstance(con, ystree.YFuncExp) and con.func_name == "SUBQ":
                for par in con.parameter_list:
                    if isinstance(par, ystree.YRawColExp) and par.column_name not in indexList:
                        indexList.append(par.column_name)
                        colList.append(par)

    #Also check indexed columns
    if tn.indexCols is not None:
        for col in tn.indexCols:
            if col.column_name not in indexList:
                indexList.append(col.column_name)
                colList.append(col)

"""
generate_code generates CUDA/OpenCL codes from the query plan tree.
Currently we only generate CUDA/OpenCL codes for star schema queries.

Several configurable variables (in config.py):
    @CODETYPE determines whether CUDA or OpenCL codes should be generated.
    0 represents CUDA and 1 represents OpenCL.

    @joinType determines whether we should generate invisible joins for star
    schema queries. 0 represents normal join and 1 represents invisible join.

    @POS describes where the data are stored in the host memory and how the
    codes should be generated. 0 means data are stored in pageable host
    memory and data are explicitly transferred. 1 means data are stored in
    pinned host memory and data are explicitly transferred. 2 means data are
    stored in pinned host memory and the kernel will directly access the data
    without explicit data transferring. 3 means data are stored in disk and only
    mapped to host memory.
"""

def generate_code(tree):

    global baseIndent
    """
    First check whether the value of each configurable variable is valid.
    All should be integers.
    """

    if CODETYPE not in [0,1]:
        print "Error! The value of CODETYPE can only be 0 or 1."
        exit(-1)

    if POS not in [0,1,2,3]:
        print "Error! The value of POS can only be 0,1,2,3."
        exit(-1)

    if joinType not in [0,1]:
        print "Error! The value of JOINTYPE can only be 0 or 1."
        exit(-1)

    DTYPE_STR = ""
    if CODETYPE == 1:
        if PID not in [0,1,2,3]:
            print "Error for PID!"
            exit(-1)

        if DTYPE not in [0,1,2]:
            print "Error! The value of DTYPE can only be 0,1,2."
            exit(-1)

        if DTYPE == 0:
            DTYPE_STR = "CL_DEVICE_TYPE_GPU"
        elif DTYPE == 1:
            DTYPE_STR = "CL_DEVICE_TYPE_CPU"
        elif DTYPE == 2:
            DTYPE_STR = "CL_DEVICE_TYPE_ACCELERATOR"

    if CODETYPE==0:
        fo = open("driver.cu","w")
    else:
        fo = open("driver.cpp","w")

    print >>fo, "/* This file is generated by code_gen.py */"
    print >>fo, "#include <stdio.h>"
    print >>fo, "#include <stdlib.h>"
    print >>fo, "#include <sys/types.h>"
    print >>fo, "#include <sys/stat.h>"
    print >>fo, "#include <fcntl.h>"
    print >>fo, "#include <sys/mman.h>"
    print >>fo, "#include <string.h>"
    print >>fo, "#include <unistd.h>"
    print >>fo, "#include <malloc.h>"
    print >>fo, "#include <time.h>"
    print >>fo, "#include <getopt.h>"
    print >>fo, "#include <linux/limits.h>"
    print >>fo, "#include \"../include/common.h\""

    if joinType == 0:
        print >>fo, "#include \"../include/hashJoin.h\""
    else:
        print >>fo, "#include \"../include/inviJoin.h\""

    print >>fo, "#include \"../include/schema.h\""

    if CODETYPE == 0:
        print >>fo, "#include \"../include/cpuCudaLib.h\""
        print >>fo, "#include \"../include/gpuCudaLib.h\""
        print >>fo, "extern struct tableNode* tableScan(struct scanNode *,struct statistic *);"
        #Indexing functions
        print >>fo, "extern void createIndex (struct tableNode *, int, int, struct statistic *);"
        print >>fo, "extern struct tableNode* indexScan (struct tableNode *, int, int, int, struct statistic *);"
        if joinType == 0:
            print >>fo, "extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);"
        else:
            print >>fo, "extern struct tableNode* inviJoin(struct joinNode *, struct statistic *);"
        print >>fo, "extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);"
        print >>fo, "extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);"
        print >>fo, "extern char* materializeCol(struct materializeNode * mn, struct statistic *);"

    else:
        print >>fo, "#include <CL/cl.h>"
        print >>fo, "#include <string>"
        print >>fo, "#include \"../include/gpuOpenclLib.h\"\n"
        print >>fo, "#include\"../include/cpuOpenclLib.h\""
        print >>fo, "using namespace std;"
        print >>fo, "extern const char * createProgram(string, int *);"

        print >>fo, "extern struct tableNode* tableScan(struct scanNode *,struct clContext *, struct statistic *);"
        if joinType == 0:
            print >>fo, "extern struct tableNode* hashJoin(struct joinNode *, struct clContext *, struct statistic *);"
        else:
            print >>fo, "extern struct tableNode* inviJoin(struct joinNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern struct tableNode* groupBy(struct groupByNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern struct tableNode* orderBy(struct orderByNode *, struct clContext *, struct statistic *);"
        print >>fo, "extern char * materializeCol(struct materializeNode * mn, struct clContext *, struct statistic *);"

    indent = baseIndent
    print >>fo, "\n#define CHECK_POINTER(p) do {\\"
    print >>fo, indent + "if(p == NULL){   \\"
    print >>fo, indent + baseIndent + "perror(\"Failed to allocate host memory\");    \\"
    print >>fo, indent + baseIndent + "exit(-1);      \\"
    print >>fo, indent + "}} while(0)"

    print >>fo, "\nint main(int argc, char ** argv){\n"

    if CODETYPE == 1:
        print >>fo, indent + "int psc = 0;"
        print >>fo, indent + "void * clTmp;"
        print >>fo, indent + "const char * ps = createProgram(\"kernel.cl\",&psc);"
        print >>fo, indent + "struct clContext context;"
        print >>fo, indent + "cl_uint numP;"
        print >>fo, indent + "cl_int error = 0;"
        print >>fo, indent + "cl_device_id device;"
        print >>fo, indent + "clGetPlatformIDs(0,NULL,&numP);"
        print >>fo, indent + "cl_platform_id * pid = new cl_platform_id[numP];"
        print >>fo, indent + "clGetPlatformIDs(numP, pid, NULL);"
        print >>fo, indent + "clGetDeviceIDs(pid[" + str(PID) + "]," + DTYPE_STR +", 1, &device, NULL);"
        print >>fo, indent + "context.context = clCreateContext(0, 1, &device, NULL, NULL, &error);"
        print >>fo, indent + "cl_command_queue_properties prop = 0;"
        print >>fo, indent + "prop |= CL_QUEUE_PROFILING_ENABLE;"
        print >>fo, indent + "context.queue = clCreateCommandQueue(context.context, device, prop, &error);"
        print >>fo, indent + "context.program = clCreateProgramWithSource(context.context, psc, (const char **)&ps, 0, &error);"
        print >>fo, indent + "error = clBuildProgram(context.program, 0, 0 , \"-I .\" , 0, 0);\n"

    else:
        print >>fo, indent + "/* For initializing CUDA device */"
        print >>fo, indent + "int * cudaTmp;"
        print >>fo, indent + "cudaMalloc((void**)&cudaTmp,sizeof(int));"
        print >>fo, indent + "cudaFree(cudaTmp);\n"


    print >>fo, indent + "int table;"
    print >>fo, indent + "int long_index;"
    print >>fo, indent + "char path[PATH_MAX];"
    print >>fo, indent + "int setPath = 0;"
    print >>fo, indent + "struct option long_options[] = {"
    print >>fo, indent + baseIndent + "{\"datadir\",required_argument,0,'0'}"
    print >>fo, indent + "};\n"

    print >>fo, indent + "while((table=getopt_long(argc,argv,\"\",long_options,&long_index))!=-1){"
    print >>fo, indent + baseIndent + "switch(table){"
    print >>fo, indent + baseIndent * 2 + "case '0':"
    print >>fo, indent + baseIndent * 3 + "setPath = 1;"
    print >>fo, indent + baseIndent * 3 + "strcpy(path,optarg);"
    print >>fo, indent + baseIndent * 3 + "break;"
    print >>fo, indent + baseIndent + "}"
    print >>fo, indent + "}\n"

    print >>fo, indent + "if(setPath == 1)"
    print >>fo, indent + baseIndent + "chdir(path);\n"

    print >>fo, indent + "struct timespec start, end;"
    print >>fo, indent + "struct timespec diskStart, diskEnd;"
    print >>fo, indent + "double diskTotal = 0;"
    print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&start);"
    print >>fo, indent + "struct statistic pp;"
    print >>fo, indent + "pp.total = pp.kernel = pp.pcie = 0;\n"

    generate_code_for_loading_tables(fo, indent, tree)

    generate_code_for_a_tree(fo, tree, 0)

    print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &end);"
    print >>fo, indent + "double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;"
    print >>fo, indent + "printf(\"Disk Load Time: %lf\\n\", diskTotal/(1000*1000));"
    print >>fo, indent + "printf(\"PCIe Time: %lf\\n\",pp.pcie);"
    print >>fo, indent + "printf(\"Kernel Time: %lf\\n\",pp.kernel);"
    print >>fo, indent + "printf(\"Total Time: %lf\\n\", timeE/(1000*1000));"
    print >>fo, "}\n"

    fo.close()

def get_subqueries(tree, subq_list):

    if isinstance(tree, ystree.OrderByNode) or isinstance(tree, ystree.GroupByNode):
        get_subqueries(tree.child, subq_list)

    elif isinstance(tree, ystree.TwoJoinNode):
        get_subqueries(tree.left_child, subq_list)
        get_subqueries(tree.right_child, subq_list)

    elif isinstance(tree, ystree.TableNode) and tree.where_condition != None:
        where_exp = tree.where_condition.where_condition_exp
        def __get_subqueries__(exp, subq_list):
            if exp is None or not isinstance(exp, ystree.YFuncExp):
                return
            if exp.func_name != "SUBQ":
                map(lambda par: __get_subqueries__(par, subq_list), exp.parameter_list)
            else:
                subq_list.append(exp)

        __get_subqueries__(where_exp, subq_list)
        return

def generate_code_for_a_tree(fo, tree, lvl):

    global baseIndent
    indent = (lvl * 3 + 1) * baseIndent

    var_subqRes = "subqRes" + str(lvl)

    print ">>> Generate code for a tree <<<"
    tree.debug(0)

    resultNode = "result"

    print >>fo, indent + "struct tableNode *" + resultNode + ";"
    print >>fo, indent + "char * " + var_subqRes + ";\n"

    tree_result = generate_code_for_a_node(fo, indent, lvl, tree)

    print >>fo, indent + resultNode + " = " + tree_result + ";"

    print >>fo, indent + "struct materializeNode mn;"
    print >>fo, indent + "mn.table = "+resultNode + ";"
    if CODETYPE == 0:
        print >>fo, indent + "char *final = materializeCol(&mn, &pp);"

        if lvl == 0:
            print >>fo, indent + "printMaterializedTable(mn, final);"

    else:
        print >>fo, indent + "materializeCol(&mn, &context,&pp);"
        print >>fo, indent + "freeTable(" + resultNode + ");\n"

    if CODETYPE == 1:
        print >>fo, indent + "clReleaseCommandQueue(context.queue);"
        print >>fo, indent + "clReleaseContext(context.context);"
        print >>fo, indent + "clReleaseProgram(context.program);\n"

#Baseline subquery execution
def generate_code_for_a_subquery(fo, lvl, rel, con, tupleNum, tableName, indexDict, currentNode, passInPos):

    indent = (lvl * 3 + 2) * baseIndent
    var_subqRes = "subqRes" + str(lvl)

    subq_id = con.parameter_list[0].cons_value
    pass_in_cols = con.parameter_list[1:]
    sub_tree = ystree.subqueries[subq_id]

    subq_select_list = sub_tree.select_list.tmp_exp_list
    if len(subq_select_list) > 1:
        print "ERROR: more than one column are selected in a subquery!"
        sub_tree.debug(0)
        print 1/0

    selectItem = subq_select_list[0]
    subq_res_size = 0
    if isinstance(selectItem, ystree.YFuncExp):
        # Assume the aggregation function with only one parameter, i.e., the column
        subq_res_col = selectItem.parameter_list[0]
    elif isinstance(selectItem, ystree.YRawColExp):
        subq_res_col = selectItem
    else:
        print "ERROR: Unknown select column type in a subquery: ", selectItem.evaluate()
        print 1/0

    if rel in ["EQ", "LTH", "GTH", "LEQ", "GEQ", "NOT_EQ"]:
        constant_len_res = True
        subq_res_size = "sizeof(float)"
    else:
        constant_len_res = False
        subq_res_size = type_length(subq_res_col.table_name, subq_res_col.column_name, subq_res_col.column_type)


    print >>fo, ""
    print >>fo, indent + "// Process the subquery"

    if isinstance(currentNode, ystree.TwoJoinNode):
        pass_in_cols = map(lambda c: ystree.__trace_to_leaf__(currentNode, c, False), pass_in_cols)

    for col in pass_in_cols:
        colLen = type_length(col.table_name, col.column_name, col.column_type)
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        print >>fo, indent + "char *" + pass_in_var + " = (char *)malloc(" + colLen + ");"
        print >>fo, indent + "CHECK_POINTER(" + pass_in_var + ");"

    print >>fo, indent + var_subqRes + " = (char *)malloc(" + (subq_res_size if constant_len_res else "sizeof(char *)") + " * " + tupleNum + ");"
    print >>fo, indent + "CHECK_POINTER(" + var_subqRes + ");\n"

    print >>fo, indent + "for(int tupleid = 0; tupleid < " + tupleNum + "; tupleid++){"

    for col in pass_in_cols:
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        colLen = type_length(col.table_name, col.column_name, col.column_type)
        if passInPos == "MEM":
            print >>fo, indent + baseIndent + "memcpy(" + pass_in_var + ", (char *)(" + tableName + "->content[" +  str(indexDict[col.table_name + "." + str(col.column_name)]) + "]) + tupleid * " + colLen + ", " + colLen + ");"
        elif passInPos == "GPU":
            print >>fo, indent + baseIndent + "CUDA_SAFE_CALL_NO_SYNC( cudaMemcpy(" + pass_in_var + ", (char *)(" + tableName + "->content[" + str(indexDict[col.table_name + "." + str(col.column_name)]) + "]) + tupleid * " + colLen + ", " + colLen + ", cudaMemcpyDeviceToHost) );"
        else:
            print "ERROR: Unknown pass in value position: ", passInPos
            exit(99)

    print >>fo, indent + baseIndent + "{"

    generate_code_for_a_tree(fo, sub_tree, lvl + 1)

    print >>fo, indent + baseIndent * 2 + ""
    if constant_len_res:
        print >>fo, indent + baseIndent * 2 + "mempcpy(" + var_subqRes + " + tupleid * " + subq_res_size + ", final, " + subq_res_size + ");"
    else:
        print >>fo, indent + baseIndent * 2 + "((char **)" + var_subqRes + ")[tupleid] = (char *)malloc(sizeof(int) + " + subq_res_size + " * mn.table->tupleNum);"
        print >>fo, indent + baseIndent * 2 + "CHECK_POINTER( ((char **)" + var_subqRes + ")[tupleid] );"
        print >>fo, indent + baseIndent * 2 + "*(int *)(((char **)" + var_subqRes + ")[tupleid]) = mn.table->tupleNum;"
        print >>fo, indent + baseIndent * 2 + "mempcpy(((char **)" + var_subqRes + ")[tupleid] + sizeof(int), final, " + subq_res_size + " * mn.table->tupleNum);"
    print >>fo, indent + baseIndent + "}"
    print >>fo, indent + "}"

    for col in pass_in_cols:
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        print >>fo, indent + "free(" + pass_in_var + ");"
    print >>fo, ""

#Indexed subquery execution
def generate_code_for_a_subquery_idx(fo, lvl, rel, con, tupleNum, tableName, indexDict, currentNode, passInPos):

    indent = (lvl * 3 + 2) * baseIndent
    var_subqRes = "subqRes" + str(lvl)

    subq_id = con.parameter_list[0].cons_value
    pass_in_cols = con.parameter_list[1:]
    sub_tree = ystree.subqueries[subq_id]

    subq_select_list = sub_tree.select_list.tmp_exp_list
    if len(subq_select_list) > 1:
        print "[ERROR] : more than one column are selected in a subquery!"
        sub_tree.debug(0)
        exit(-1)

    selectItem = subq_select_list[0]
    subq_res_size = 0
    if isinstance(selectItem, ystree.YFuncExp):
        # Assume the aggregation function with only one parameter, i.e., the column
        subq_res_col = selectItem.parameter_list[0]
    elif isinstance(selectItem, ystree.YRawColExp):
        subq_res_col = selectItem
    else:
        print "ERROR: Unknown select column type in a subquery: ", selectItem.evaluate()
        exit(-1)

    if rel in ["EQ", "LTH", "GTH", "LEQ", "GEQ", "NOT_EQ"]:
        constant_len_res = True
        subq_res_size = "sizeof(float)"
    else:
        constant_len_res = False
        subq_res_size = type_length(subq_res_col.table_name, subq_res_col.column_name, subq_res_col.column_type)

    print >>fo, ""
    print >>fo, indent + "// Process the subquery"

    if isinstance(currentNode, ystree.TwoJoinNode):
        pass_in_cols = map(lambda c: ystree.__trace_to_leaf__(currentNode, c, False), pass_in_cols)

    for col in pass_in_cols:
        colLen = type_length(col.table_name, col.column_name, col.column_type)
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        print >>fo, indent + "char *" + pass_in_var + " = (char *)malloc(" + colLen + ");"
        print >>fo, indent + "CHECK_POINTER(" + pass_in_var + ");"

    print >>fo, indent + var_subqRes + " = (char *)malloc(" + (subq_res_size if constant_len_res else "sizeof(char *)") + " * " + tupleNum + ");"
    print >>fo, indent + "CHECK_POINTER(" + var_subqRes + ");\n"

    print >>fo, indent + "for(int tupleid = 0; tupleid < " + tupleNum + "; tupleid++){"

    for col in pass_in_cols:
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        colLen = type_length(col.table_name, col.column_name, col.column_type)
        if passInPos == "MEM":
            print >>fo, indent + baseIndent + "memcpy(" + pass_in_var + ", (char *)(" + tableName + "->content[" +  str(indexDict[col.table_name + "." + str(col.column_name)]) + "]) + tupleid * " + colLen + ", " + colLen + ");"
        elif passInPos == "GPU":
            print >>fo, indent + baseIndent + "CUDA_SAFE_CALL_NO_SYNC( cudaMemcpy(" + pass_in_var + ", (char *)(" + tableName + "->content[" + str(indexDict[col.table_name + "." + str(col.column_name)]) + "]) + tupleid * " + colLen + ", " + colLen + ", cudaMemcpyDeviceToHost) );"
        else:
            print "ERROR: Unknown pass in value position: ", passInPos
            exit(99)

    print >>fo, indent + baseIndent + "{"

    #Sofoklis Debug
    print >>fo, indent + baseIndent + "//==========Start SUB-QUERY processing (with indexing)=========="

    # Sofoklis Comments for indexing implemenation
    #-----------------------------------------------------------------------------------
    # Step 1 - Search for linking predicates
    # Step 2 - Create build index (by sorting linking predicate)
    # Step 3 - If there is an index do binary search instead of scan
    #-----------------------------------------------------------------------------------

    #Explore all the nested block
    nodesToExplore = []
    nodesHierarchy = {} #Key = Parent, Value = [Child1, Child2]
    nodesToExplore.append(sub_tree)
    while len(nodesToExplore) != 0:

        #Get next node
        currNode = nodesToExplore.pop()

        #Add left and right nodes from joins
        if isinstance(currNode, ystree.TwoJoinNode):

            #Explore right and left childs
            nodesToExplore.append(currNode.left_child)
            nodesToExplore.append(currNode.right_child)

            #Keep Hierarchy
            chList = []
            chList.append(currNode.left_child)
            chList.append(currNode.right_child)
            nodesHierarchy[currNode] = chList

        #Found leafs (i.e. tables)
        elif isinstance(currNode, ystree.TableNode):

            #Check if there is a where condition
            if currNode.where_condition is not None:

                #Keep colunms that need to be ordered
                columnsToShort = []

                #Analyze where condition
                whereList = []
                relList = []
                conList = []
                get_where_attr(currNode.where_condition.where_condition_exp, whereList, relList, conList)

                #Check if it filters a linking predicate
                for col in conList:
                    if isinstance(col, ystree.YRawColExp):

                        #Mark all columns that need to be sorted
                        for linkingPredicate in pass_in_cols:
                            if col.table_name == linkingPredicate.table_name and col.column_name == linkingPredicate.column_name:

                                print "[INFO]: Found linking predicate column: "+linkingPredicate.table_name+"."+str(linkingPredicate.column_name)

                                #Add to the list of columns that need to be sorted
                                columnsToShort.append(col)

                #Check if we have to short this table
                if len(columnsToShort) != 0:

                    #Add columns to create index
                    currNode.indexCols = copy.deepcopy(columnsToShort)

                    #Remove regular scan and add idex scan
                    currNode.indexScan = copy.deepcopy(currNode.where_condition)
                    currNode.where_condition = None

        else:

            #If this is anything else (order, group by etc) we move to the next one
            nodesToExplore.append(currNode.child)

            #Keep Hierarchy
            chList = []
            chList.append(currNode.child)
            nodesHierarchy[currNode] = chList

    print "================================================================================================="

    generate_code_for_a_tree(fo, sub_tree, lvl + 1)

    print >>fo, indent + baseIndent * 2 + ""
    if constant_len_res:
        print >>fo, indent + baseIndent * 2 + "mempcpy(" + var_subqRes + " + tupleid * " + subq_res_size + ", final, " + subq_res_size + ");"
    else:
        print >>fo, indent + baseIndent * 2 + "((char **)" + var_subqRes + ")[tupleid] = (char *)malloc(sizeof(int) + " + subq_res_size + " * mn.table->tupleNum);"
        print >>fo, indent + baseIndent * 2 + "CHECK_POINTER( ((char **)" + var_subqRes + ")[tupleid] );"
        print >>fo, indent + baseIndent * 2 + "*(int *)(((char **)" + var_subqRes + ")[tupleid]) = mn.table->tupleNum;"
        print >>fo, indent + baseIndent * 2 + "mempcpy(((char **)" + var_subqRes + ")[tupleid] + sizeof(int), final, " + subq_res_size + " * mn.table->tupleNum);"
    print >>fo, indent + baseIndent + "}"
    print >>fo, indent + "}"

    for col in pass_in_cols:
        pass_in_var = "_" + col.table_name + "_" + str(col.column_name)
        print >>fo, indent + "free(" + pass_in_var + ");"
    print >>fo, ""

"""
gpudb_code_gen: entry point for code generation.
"""

def gpudb_code_gen(argv):
    pwd = os.getcwd()
    resultDir = "./src"
    utilityDir = "./utility"

    if CODETYPE == 0:
        codeDir = "./cuda"
    else:
        codeDir = "./opencl"

    includeDir = "./include"
    schemaFile = None

    #Exec query
    if len(sys.argv) == 3 or len(sys.argv) == 4:
        tree_node = ystree.ysmart_tree_gen(argv[1],argv[2])
        if tree_node is None:
            exit(-1)

    #Data loading
    elif len(sys.argv) == 2:
        schemaFile = ystree.ysmart_get_schema(argv[1])

    if os.path.exists(resultDir) is False:
        os.makedirs(resultDir)

    os.chdir(resultDir)
    if os.path.exists(codeDir) is False:
        os.makedirs(codeDir)

    if os.path.exists(includeDir) is False:
        os.makedirs(includeDir)

    os.chdir(includeDir)

    generate_schema_file()

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(utilityDir)

    generate_loader()
    if SOA == 1:
        generate_soa()

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(codeDir)

    if len(sys.argv) >= 3:
        if len(sys.argv) > 3:
            global optimization
            optimization = argv[3]
        generate_code(tree_node)

    os.chdir(pwd)
    os.chdir(resultDir)
    os.chdir(utilityDir)

    if schemaFile is not None:
        metaFile = open(".metadata",'wb')
        pickle.dump(schemaFile, metaFile)
        metaFile.close()

    os.chdir(pwd)

def generate_code_for_a_node(fo, indent, lvl, node):

    if isinstance(node, ystree.TwoJoinNode):
        return generate_code_for_a_two_join_node(fo, indent, lvl, node)
    elif isinstance(node, ystree.GroupByNode):
        return generate_code_for_a_group_by_node(fo, indent, lvl, node)
    elif isinstance(node, ystree.OrderByNode):
        return generate_code_for_a_order_by_node(fo, indent, lvl, node)
    elif isinstance(node, ystree.TableNode):
        return generate_code_for_a_table_node(fo, indent, lvl, node)
    elif isinstance(node, ystree.SelectProjectNode):
        return generate_code_for_a_select_project_node(fo, indent, lvl, node)

def generate_code_for_a_select_project_node(fo, indent, lvl, spn):

    inputNode = generate_code_for_a_node(fo, indent, lvl, spn.child)

    return inputNode

def generate_code_for_a_order_by_node(fo, indent, lvl, obn):

    inputNode = generate_code_for_a_node(fo, indent, lvl, obn.child)

    orderby_exp_list = obn.order_by_clause.orderby_exp_list
    odLen = len(orderby_exp_list)

    resultNode = inputNode + "_ob"
    print >>fo, indent + "struct tableNode * " + resultNode + ";"

    print >>fo, indent + "{\n"
    indent += baseIndent

    print >>fo, indent + "struct orderByNode * odNode = (struct orderByNode *) malloc(sizeof(struct orderByNode));"
    print >>fo, indent + "CHECK_POINTER(odNode);"
    print >>fo, indent + "odNode->table = " + inputNode +";"
    print >>fo, indent + "odNode->orderByNum = " + str(odLen) + ";"
    print >>fo, indent + "odNode->orderBySeq = (int *) malloc(sizeof(int) * odNode->orderByNum);"
    print >>fo, indent + "CHECK_POINTER(odNode->orderBySeq);"
    print >>fo, indent + "odNode->orderByIndex = (int *) malloc(sizeof(int) * odNode->orderByNum);"
    print >>fo, indent + "CHECK_POINTER(odNode->orderByIndex);"

    for i in range(0, odLen):
        seq = obn.order_by_clause.order_indicator_list[i]
        if seq == "ASC":
            print >>fo, indent + "odNode->orderBySeq[" + str(i) + "] = ASC;"
        else:
            print >>fo, indent + "odNode->orderBySeq[" + str(i) + "] = DESC;"

        print >>fo, indent + "odNode->orderByIndex[" + str(i) + "] = " + str(orderby_exp_list[i].column_name) + ";"

    if CODETYPE == 0:
        print >>fo, indent + resultNode + " = orderBy(odNode, &pp);"
    else:
        print >>fo, indent + resultNode + " = orderBy(odNode, &context, &pp);"

    print >>fo, indent + "freeOrderByNode(odNode);\n"

    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}\n"

    return resultNode

def generate_code_for_a_group_by_node(fo, indent, lvl, gbn):

    inputNode = generate_code_for_a_node(fo, indent, lvl, gbn.child)

    gb_exp_list = gbn.group_by_clause.groupby_exp_list
    select_list = gbn.select_list.tmp_exp_list
    selectLen = len(select_list)
    gbLen = len(gb_exp_list)

    resultNode = inputNode + "_gb"
    print >>fo, indent + "struct tableNode * " + resultNode + ";"

    print >>fo, indent + "{\n"
    indent += baseIndent

    print >>fo, indent + "struct groupByNode * gbNode = (struct groupByNode *) malloc(sizeof(struct groupByNode));"
    print >>fo, indent + "CHECK_POINTER(gbNode);"
    print >>fo, indent + "gbNode->table = " + inputNode +";"
    print >>fo, indent + "gbNode->groupByColNum = " + str(gbLen) + ";"
    print >>fo, indent + "gbNode->groupByIndex = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
    print >>fo, indent + "CHECK_POINTER(gbNode->groupByIndex);"
    print >>fo, indent + "gbNode->groupByType = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
    print >>fo, indent + "CHECK_POINTER(gbNode->groupByType);"
    print >>fo, indent + "gbNode->groupBySize = (int *)malloc(sizeof(int) * " + str(gbLen) + ");"
    print >>fo, indent + "CHECK_POINTER(gbNode->groupBySize);"


    for i in range(0,gbLen):
        exp = gb_exp_list[i]
        if isinstance(exp, ystree.YRawColExp):
            print >>fo, indent + "gbNode->groupByIndex[" + str(i) + "] = " + str(exp.column_name) + ";"
            print >>fo, indent + "gbNode->groupByType[" + str(i) + "] = gbNode->table->attrType[" + str(exp.column_name) + "];"
            print >>fo, indent + "gbNode->groupBySize[" + str(i) + "] = gbNode->table->attrSize[" + str(exp.column_name) + "];"
        elif isinstance(exp, ystree.YConsExp):
            print >>fo, indent + "gbNode->groupByIndex[" + str(i) + "] = -1;"
            print >>fo, indent + "gbNode->groupByType[" + str(i) + "] = INT;"
            print >>fo, indent + "gbNode->groupBySize[" + str(i) + "] = sizeof(int);"
        else:
            print 1/0


    print >>fo, indent + "gbNode->outputAttrNum = " + str(selectLen) + ";"
    print >>fo, indent + "gbNode->attrType = (int *) malloc(sizeof(int) *" + str(selectLen) + ");"
    print >>fo, indent + "CHECK_POINTER(gbNode->attrType);"
    print >>fo, indent + "gbNode->attrSize = (int *) malloc(sizeof(int) *" + str(selectLen) + ");"
    print >>fo, indent + "CHECK_POINTER(gbNode->attrSize);"
    print >>fo, indent + "gbNode->tupleSize = 0;"
    print >>fo, indent + "gbNode->gbExp = (struct groupByExp *) malloc(sizeof(struct groupByExp) * " + str(selectLen) + ");"

    for i in range(0,selectLen):
        exp = select_list[i]
        if isinstance(exp, ystree.YFuncExp):

            print >>fo, indent + "gbNode->tupleSize += sizeof(float);"
            print >>fo, indent + "gbNode->attrType[" + str(i) + "] = FLOAT;"
            print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(float);"
            print >>fo, indent + "gbNode->gbExp["+str(i)+"].func = " + exp.func_name + ";"
            para = exp.parameter_list[0]
            mathFunc = mathExp()
            mathFunc.addOp(para)
            prefix = indent + "gbNode->gbExp[" + str(i) + "].exp"
            printMathFunc(fo,prefix, mathFunc)

        elif isinstance(exp, ystree.YRawColExp):
            colIndex = exp.column_name
            print >>fo, indent + "gbNode->attrType[" + str(i) + "] = " + inputNode + "->attrType[" + str(colIndex) + "];"
            print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = " + inputNode + "->attrSize[" + str(colIndex) + "];"
            print >>fo, indent + "gbNode->tupleSize += "+inputNode + "->attrSize[" + str(colIndex) + "];"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].func = NOOP;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.op = NOOP;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.exp = NULL;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opNum = 1;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opType = COLUMN;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opValue = " + str(exp.column_name) + ";"

        else:
            if exp.cons_type == "INTEGER":
                print >>fo, indent + "gbNode->attrType[" + str(i) + "] = INT;"
                print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(int);"
                print >>fo, indent + "gbNode->tupleSize += sizeof(int);"
            elif exp.cons_type == "FLOAT":
                print >>fo, indent + "gbNode->attrType[" + str(i) + "] = FLOAT;"
                print >>fo, indent + "gbNode->attrSize[" + str(i) + "] = sizeof(float);"
                print >>fo, indent + "gbNode->tupleSize += sizeof(float);"
            else:
                print 1/0

            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].func = NOOP;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.op = NOOP;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.exp = NULL;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opNum = 1;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opType = CONS;"
            print >>fo, indent + "gbNode->gbExp[" + str(i) + "].exp.opValue = " + str(exp.cons_value) + ";"

    if CODETYPE == 0:
        print >>fo, indent + resultNode + " = groupBy(gbNode, &pp);"
    else:
        print >>fo, indent + resultNode + " = groupBy(gbNode, &context, &pp);"
        print >>fo, indent + "freeGroupByNode(gbNode);\n"


    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}\n"

    return resultNode

def generate_code_for_a_two_join_node(fo, indent, lvl, jn):

    leftName, rightName = generate_code_for_a_node(fo, indent, lvl, jn.left_child), generate_code_for_a_node(fo, indent, lvl, jn.right_child)
    var_subqRes = "subqRes" + str(lvl)

    if leftName is None or rightName is None:
        print 1/0

    print >>fo, indent + "// Join two tables: " + leftName + ", " + rightName # conditions?
    resName = leftName + "_" + rightName
    print >>fo, indent + "struct tableNode *" + resName + ";\n"

    print >>fo, indent + "{\n"

    jName = "jNode"
    indent += baseIndent
    print >>fo, indent + "struct joinNode " + jName + ";"
    print >>fo, indent + jName + ".leftTable = " + leftName + ";"
    print >>fo, indent + jName + ".rightTable = " + rightName + ";"

    lOutList = []
    rOutList = []

    lPosList = []
    rPosList = []

    lAttrList = []
    rAttrList = []

    selectList = jn.select_list.tmp_exp_list
    for exp in jn.select_list.tmp_exp_list:
        index = jn.select_list.tmp_exp_list.index(exp)
        if isinstance(exp, ystree.YRawColExp):
            colAttr = columnAttr()
            colAttr.type = exp.column_type
            if exp.table_name == "LEFT":
                if joinType == 0:
                    lOutList.append(exp.column_name)
                elif joinType == 1:
                    newExp = ystree.__trace_to_leaf__(jn, exp, False) # Get the real table name
                    lOutList.append(newExp.column_name)

                lAttrList.append(colAttr)
                lPosList.append(index)

            elif exp.table_name == "RIGHT":
                if joinType == 0:
                    rOutList.append(exp.column_name)
                elif joinType == 1:
                    newExp = ystree.__trace_to_leaf__(jn, exp, False)
                    rOutList.append(newExp.column_name)

                rAttrList.append(colAttr)
                rPosList.append(index)

    if jn.where_condition is not None:
        whereList = []
        relList = []
        conList = []
        get_where_attr(jn.where_condition.where_condition_exp, whereList, relList, conList)
        index = len(lPosList) + len(rPosList)
        for col in whereList:
            if (col.table_name == "LEFT" and col.column_name in lOutList) or (col.table_name == "RIGHT" and col.column_name in rOutList):
                continue

            colAttr = columnAttr()
            colAttr.type = col.column_type
            if col.table_name == "LEFT":
                if joinType == 0:
                    lOutList.append(col.column_name)
                elif joinType == 1:
                    newExp = ystree.__trace_to_leaf__(jn, col, False)
                    lOutList.append(newExp.column_name)
                lAttrList.append(colAttr)
                lPosList.append(index)
                index = index + 1
            elif col.table_name == "RIGHT":
                if joinType == 0:
                    rOutList.append(col.column_name)
                elif joinType == 1:
                    newExp = ystree.__trace_to_leaf__(jn, col, False)
                    rOutList.append(newExp.column_name)
                rAttrList.append(colAttr)
                rPosList.append(index)
                index = index + 1

        for con in conList:
            if isinstance(con, ystree.YFuncExp) and con.func_name == "SUBQ":
                for par in con.parameter_list:
                    if isinstance(par, ystree.YRawColExp):
                        if (par.table_name == "LEFT" and par.column_name in lOutList) or (par.table_name == "RIGHT" and par.column_name in rOutList):
                            continue

                        col = par
                        colAttr = columnAttr()
                        colAttr.type = col.column_type
                        if col.table_name == "LEFT":
                            if joinType == 0:
                                lOutList.append(col.column_name)
                            elif joinType == 1:
                                newExp = ystree.__trace_to_leaf__(jn, col, False)
                                lOutList.append(newExp.column_name)
                            lAttrList.append(colAttr)
                            lPosList.append(index)
                            index = index + 1
                        elif col.table_name == "RIGHT":
                            if joinType == 0:
                                rOutList.append(col.column_name)
                            elif joinType == 1:
                                newExp = ystree.__trace_to_leaf__(jn, col, False)
                                rOutList.append(newExp.column_name)
                            rAttrList.append(colAttr)
                            rPosList.append(index)
                            index = index + 1

    pkList = jn.get_pk()

    if (len(pkList[0]) != len(pkList[1])):
        print "ERROR: the join indices do not match!"
        exit(-1)

    leftIndex = None
    rightIndex = None
    if joinType == 0:
        for exp in pkList[0]:
            leftIndex = 0
            if isinstance(jn.left_child, ystree.TableNode):
                leftIndex = -1
                for tmp in jn.left_child.select_list.tmp_exp_list:
                    if exp.column_name == tmp.column_name:
                        leftIndex = jn.left_child.select_list.tmp_exp_list.index(tmp)
                        break
                if leftIndex == -1:
                    print 1/0
            else:
                leftIndex = exp.column_name

    elif joinType == 1:
        for exp in pkList[0]:
            newExp = ystree.__trace_to_leaf__(jn, exp, True)
            leftIndex = newExp.column_name


    for exp in pkList[1]:
        rightIndex = 0
        if isinstance(jn.right_child, ystree.TableNode):
            rightIndex = -1
            for tmp in jn.right_child.select_list.tmp_exp_list:
                if exp.column_name == tmp.column_name:
                    rightIndex = jn.right_child.select_list.tmp_exp_list.index(tmp)
                    break
            if rightIndex == -1:
                print 1/0
        else:
            rightIndex = exp.column_name

    if leftIndex is None or rightIndex is None:
        print "ERROR: Failed to find join indices for two tables"
        exit(-1)

    print >>fo, indent + jName + ".totalAttr = " + str(len(rOutList) + len(lOutList)) + ";"
    print >>fo, indent + jName + ".keepInGpu = (int *) malloc(sizeof(int) * " + str(len(rOutList) + len(lOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".keepInGpu);"

    if keepInGpu == 0:
        print >>fo, indent + "for(int k=0; k<" + str(len(rOutList) + len(lOutList))  + "; k++)"
        print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 0;"
    else:
        print >>fo, indent + "for(int k=0; k<" + str(len(rOutList) + len(lOutList))  + "; k++)"
        print >>fo, indent + baseIndent + jName + ".keepInGpu[k] = 1;"

    print >>fo, indent + jName + ".leftOutputAttrNum = " + str(len(lOutList)) + ";"
    print >>fo, indent + jName + ".rightOutputAttrNum = " + str(len(rOutList)) + ";"

    print >>fo, indent + jName + ".leftOutputAttrType = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".leftOutputAttrType);"
    print >>fo, indent + jName + ".leftOutputIndex = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".leftOutputIndex);"
    print >>fo, indent + jName + ".leftPos = (int *)malloc(sizeof(int)*" + str(len(lOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".leftPos);"
    print >>fo, indent + jName + ".tupleSize = 0;"
    for j in range(0,len(lOutList)):
        ctype = to_ctype(lAttrList[j].type)
        print >>fo, indent + jName + ".leftOutputIndex[" + str(j) + "] = " + str(lOutList[j]) + ";"
        print >>fo, indent + jName + ".leftOutputAttrType[" + str(j) + "] = " + ctype + ";"
        print >>fo, indent + jName + ".leftPos[" + str(j) + "] = " + str(lPosList[j]) + ";"
        print >>fo, indent + jName + ".tupleSize += " + leftName + "->attrSize[" + str(lOutList[j]) + "];"

    print >>fo, indent + jName + ".rightOutputAttrType = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".rightOutputAttrType);"
    print >>fo, indent + jName + ".rightOutputIndex = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".rightOutputIndex);"
    print >>fo, indent + jName + ".rightPos = (int *)malloc(sizeof(int)*" + str(len(rOutList)) + ");"
    print >>fo, indent + "CHECK_POINTER(" + jName + ".rightPos);"
    for j in range(0,len(rOutList)):
        ctype = to_ctype(rAttrList[j].type)
        print >>fo, indent + jName + ".rightOutputIndex[" + str(j) + "] = " + str(rOutList[j]) + ";"
        print >>fo, indent + jName + ".rightOutputAttrType[" + str(j) + "] = " + ctype + ";"
        print >>fo, indent + jName + ".rightPos[" + str(j) + "] = " + str(rPosList[j]) + ";"
        print >>fo, indent + jName + ".tupleSize += " + rightName + "->attrSize[" + str(rOutList[j]) + "];"

    print >>fo, indent + jName + ".leftKeyIndex = " + str(leftIndex) + ";"
    print >>fo, indent + jName + ".rightKeyIndex = " + str(rightIndex) + ";"

    print >>fo, indent + "struct tableNode *joinRes;"
    if CODETYPE == 0:
        print >>fo, indent + "joinRes = hashJoin(&" + jName + ",&pp);\n"
    else:
        print >>fo, indent + "joinRes = hashJoin(&" + jName + ", &context, &pp);\n"

    if jn.where_condition is not None and not jn.where_condition.where_condition_exp.compare(jn.join_condition.where_condition_exp):
        expList = []
        def get_join_exps(exp, expList):
            if isinstance(exp, ystree.YFuncExp):
                if exp.func_name in ["AND", "OR"]:
                    for x in exp.parameter_list:
                        if isinstance(x, ystree.YFuncExp):
                            get_join_exps(x, expList)
                else:
                    expList.append(exp)

        get_join_exps(jn.where_condition.where_condition_exp, expList)

        relName = "joinRel"
        print >>fo, indent + "// Where conditions: " + jn.where_condition.where_condition_exp.evaluate()
        print >>fo, indent + "struct scanNode " + relName + ";"
        print >>fo, indent + relName + ".tn = joinRes;"
        print >>fo, indent + relName + ".hasWhere = 1;"
        print >>fo, indent + relName + ".whereAttrNum = " + str(len(expList)) + ";"
        print >>fo, indent + relName + ".whereIndex = (int *)malloc(sizeof(int) * " + str(len(expList)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".whereIndex);"
        print >>fo, indent + relName + ".outputNum = " + str(len(selectList)) + ";"
        print >>fo, indent + relName + ".outputIndex = (int *)malloc(sizeof(int) * " + str(len(selectList)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".outputIndex);"


        for i in range(0, len(selectList)):
            print >>fo, indent + relName + ".outputIndex[" + str(i) + "] = " + str(i) + ";"


        def col2index_in_joinRes(col):
            if col.table_name == "LEFT":
                return lPosList[lOutList.index(col.column_name)]
            elif col.table_name == "RIGHT":
                return rPosList[rOutList.index(col.column_name)]

        where_col_dict = {}
        for i in range(0, len(expList)):
            exp = expList[i]
            if not isinstance(exp, ystree.YFuncExp) or len(exp.parameter_list) != 2:
                print "ERROR: doesn't support join condition: ", exp.evaluate()
                exit(99)

            left_col = exp.parameter_list[0]
            right_col = exp.parameter_list[1]
            if not isinstance(left_col, ystree.YRawColExp):
                print "ERROR: the left side of join must be a column!: ", left_col.evaluate()
                exit(99)

            if not isinstance(right_col, ystree.YRawColExp) and not (isinstance(right_col, ystree.YFuncExp) and right_col.func_name == "SUBQ"):
                print "ERROR: the right side of join must be a column or a subquery!: ", right_col.evaluate()
                exit(99)

            if left_col.evaluate() not in where_col_dict.keys():
                print >>fo, indent + relName + ".whereIndex[" + str(i) + "] = " + str(col2index_in_joinRes(left_col)) + ";"
                where_col_dict[left_col.evaluate()] = i

        if keepInGpu == 0:
            print >>fo, indent + relName + ".KeepInGpu = 0;"
        else:
            print >>fo, indent + relName + ".keepInGpu = 1;"

        print >>fo, indent + relName + ".filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".filter);"

        print >>fo, indent + "(" + relName + ".filter)->nested = 0;"
        print >>fo, indent + "(" + relName + ".filter)->expNum = " + str(len(expList)) + ";"
        print >>fo, indent + "(" + relName + ".filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *" + str(len(expList)) + ");"
        print >>fo, indent + "CHECK_POINTER((" + relName + ".filter)->exp);"

        if jn.where_condition.where_condition_exp.func_name in ["AND","OR"]:
            print >>fo, indent + "(" + relName + ".filter)->andOr = " + jn.where_condition.where_condition_exp.func_name + ";"
        else:
            print >>fo, indent + "(" + relName + ".filter)->andOr = EXP;"

        for i in range(0, len(expList)):
            exp = expList[i]
            left_col = exp.parameter_list[0]
            right_col = exp.parameter_list[1]

            colType = left_col.column_type
            ctype = to_ctype(colType)

            print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].index    = " + str(where_col_dict[left_col.evaluate()]) + ";"

            print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + exp.func_name + "_VEC;"

            if isinstance(right_col, ystree.YRawColExp):
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = GPU;"
                print >>fo, indent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &joinRes->content[" + str(col2index_in_joinRes(right_col)) + "], sizeof(void *));"
            else:
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = MEM;"

                indexDict = {}
                for j in range(0, len(lOutList)):
                    col = ystree.YRawColExp("LEFT", "")
                    col.column_name = lOutList[j]
                    indexDict[ystree.__trace_to_leaf__(jn, col, False).evaluate()] = lPosList[j]
                for j in range(0, len(rOutList)):
                    col = ystree.YRawColExp("RIGHT", "")
                    col.column_name = rOutList[j]
                    indexDict[ystree.__trace_to_leaf__(jn, col, False).evaluate()] = rPosList[j]

                generate_code_for_a_subquery(fo, lvl, exp.func_name, right_col, "joinRes->tupleNum", "joinRes", indexDict, jn, "GPU")

                print >>fo, indent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &" + var_subqRes + ", sizeof(void *));"

        if CODETYPE == 0:
            print >>fo, indent + resName + " = tableScan(&" + relName + ", &pp);"
        else:
            print >>fo, indent + resName + " = tableScan(&" + relName + ", &context, &pp);"

        print >>fo, indent + "freeScan(&" + relName + ");\n"

        if CODETYPE == 1:
            print >>fo, indent + "clFinish(context.queue);"

    else:
        print >>fo, indent + resName + " = joinRes;"

    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}\n"

    return resName

table_abbr = {
    "part" : "pa",
    "supplier" : "su",
    "customer" : "cu",
    "nation" : "na",
    "region" : "re",
    "partsupp" : "ps"
    }

table_refs = {
    "part" : 0,
    "supplier" : 0,
    "customer" : 0,
    "nation" : 0,
    "region" : 0,
    "partsupp" : 0
    }

def generate_code_for_a_table_node(fo, indent, lvl, tn):
    global loaded_table_list

    resName =  tn.table_name.lower()[0:2] if table_abbr[tn.table_name.lower()] == None else table_abbr[tn.table_name.lower()]
    resName = resName + str(table_refs[tn.table_name.lower()])
    table_refs[tn.table_name.lower()] = table_refs[tn.table_name.lower()] + 1
    tnName = tn.table_name.lower() + "Table"
    var_subqRes = "subqRes" + str(lvl)
    print >>fo, indent + "// Load columns from the table " + tn.table_name.upper()
    print >>fo, indent + "struct tableNode *" + resName + ";"

    print >>fo, indent + "{"
    indent += baseIndent

    # indexList = []
    # colList   = []
    # if tn.table_name in loaded_table_list.keys():
    #     tnName = tn.table_name.lower() + "Table"
    #     indexList, colList = unmerge(loaded_table_list[tn.table_name])
    # else:
    #     generate_col_list(tn, indexList, colList)
    #     tnName = generate_code_for_loading_a_table(fo, indent, tn.table_name, merge(indexList, colList))

    print >>fo, indent + "struct tableNode *" + tnName + ";"
    print >>fo, indent + "int outFd;"
    print >>fo, indent + "long outSize;"
    print >>fo, indent + "char *outTable;"
    print >>fo, indent + "long offset, tupleOffset;"
    print >>fo, indent + "int blockTotal;"
    print >>fo, indent + "struct columnHeader header;\n"

    indexList = []
    colList = []
    generate_col_list(tn, indexList, colList)

    totalAttr = len(indexList)
    if totalAttr <= 0:
        print "ERROR: Failed to generate code for tableNode " + tn.table_name.lower() + ": no column is specified"
        exit(-1)

    selectList = tn.select_list.tmp_exp_list

    firstTableFile = tn.table_name + str(colList[0].column_name)
    print >>fo, indent + "// Retrieve the block number from " + firstTableFile
    print >>fo, indent + "outFd = open(\"" + firstTableFile + "\", O_RDONLY);"
    print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
    print >>fo, indent + "blockTotal = header.blockTotal;"
    print >>fo, indent + "close(outFd);"
    print >>fo, indent + "offset = 0;"
    print >>fo, indent + "tupleOffset = 0;"
    print >>fo, indent + resName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
    print >>fo, indent + "CHECK_POINTER("+ resName + ");"
    print >>fo, indent + "initTable(" + resName + ");"

    print >>fo, indent + "for(int i = 0; i < blockTotal; i++){\n"
    indent += baseIndent
    print >>fo, indent + "// Table initialization"
    print >>fo, indent + tnName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
    print >>fo, indent + "CHECK_POINTER(" + tnName + ");"
    print >>fo, indent + tnName + "->totalAttr = " + str(totalAttr) + ";"
    print >>fo, indent + tnName + "->attrType = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrType);"
    print >>fo, indent + tnName + "->attrSize = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrSize);"
    print >>fo, indent + tnName + "->attrIndex = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrIndex);"
    print >>fo, indent + tnName + "->attrTotalSize = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrTotalSize);"
    print >>fo, indent + tnName + "->dataPos = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataPos);"
    print >>fo, indent + tnName + "->dataFormat = (int *) malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataFormat);"
    print >>fo, indent + tnName + "->content = (char **)malloc(sizeof(char *) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->content);\n"

    tupleSize = "0"
    for i in range(0, totalAttr):
        col = colList[i]
        ctype = to_ctype(col.column_type)
        colIndex = int(col.column_name)
        colLen = type_length(tn.table_name, colIndex, col.column_type)
        tupleSize += " + " + colLen

        print >>fo, indent + "// Load column " + str(colIndex) + ", type: " + col.column_type
        print >>fo, indent + tnName + "->attrSize[" + str(i) + "] = " + colLen + ";"
        print >>fo, indent + tnName + "->attrIndex["+ str(i) + "] = " + str(colIndex) + ";"
        print >>fo, indent + tnName + "->attrType[" + str(i) + "] = " + ctype + ";"

        if POS == 0:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"
        elif POS == 1:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = PINNED;"
        elif POS == 2:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = UVA;"
        elif POS == 3:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MMAP;"
        else:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"

        print >>fo, indent + "outFd = open(\"" + tn.table_name + str(colIndex) + "\", O_RDONLY);"
        print >>fo, indent + "offset = i * sizeof(struct columnHeader) + tupleOffset * " + str(colLen) + ";"
        print >>fo, indent + "lseek(outFd, offset, SEEK_SET);"
        print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
        print >>fo, indent + "offset += sizeof(struct columnHeader);"
        print >>fo, indent + tnName + "->dataFormat[" + str(i) + "] = header.format;"
        print >>fo, indent + "outSize = header.tupleNum * " + colLen + ";"
        print >>fo, indent + tnName + "->attrTotalSize[" + str(i) + "] = outSize;\n"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
        print >>fo, indent + "outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"

        if CODETYPE == 0:
            if POS == 1:
                print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName + "->content[" + str(i) + "], outSize));"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 2:
                print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName+"->content["+str(i)+"], outSize));"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 3:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
            else:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
        else:
            if POS == 0:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 3:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
            else:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)clCreateBuffer(context.context, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, outSize, NULL, 0);"
                print >>fo, indent + "clTmp = clEnqueueMapBuffer(context.queue, (cl_mem)" + tnName + "->content[" + str(i) + "], CL_TRUE,CL_MAP_WRITE,0,outSize, 0, 0, 0, 0);"
                print >>fo, indent + "memcpy(clTmp, outTable, outSize);"
                print >>fo, indent + "clEnqueueUnmapMemObject(context.queue, (cl_mem)" + tnName + "->content[" + str(i) + "], clTmp, 0, 0, 0);"

        print >>fo, indent + "munmap(outTable, outSize);"
        print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
        print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
        print >>fo, indent + "close(outFd);\n"

    print >>fo, indent + tnName + "->tupleSize = " + tupleSize + ";"
    print >>fo, indent + tnName + "->tupleNum = header.tupleNum;"
    print >>fo, indent + tnName + "->colIdxNum = 0;\n"


    if tn.where_condition is not None:
        whereList = []
        relList = []
        conList = []

        get_where_attr(tn.where_condition.where_condition_exp, whereList, relList, conList)
        newWhereList = []
        whereLen = count_whereList(whereList, newWhereList)
        nested = count_whereNested(tn.where_condition.where_condition_exp)

        if nested != 0:
            print "Not supported yet: the where expression is too complicated"
            print 1/0

        relName = tn.table_name.lower() + "Rel"
        print >>fo, indent + "// Where conditions: " + tn.where_condition.where_condition_exp.evaluate()
        print >>fo, indent + "struct scanNode " + relName + ";"
        print >>fo, indent + relName + ".tn = " + tnName + ";"
        print >>fo, indent + relName + ".hasWhere = 1;"
        print >>fo, indent + relName + ".whereAttrNum = " + str(whereLen) + ";"
        print >>fo, indent + relName + ".whereIndex = (int *)malloc(sizeof(int) * " + str(len(whereList)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".whereIndex);"
        print >>fo, indent + relName + ".outputNum = " + str(len(selectList)) + ";"
        print >>fo, indent + relName + ".outputIndex = (int *)malloc(sizeof(int) * " + str(len(selectList)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".outputIndex);"

        for i in range(0, len(selectList)):
            colIndex = selectList[i].column_name
            outputIndex = indexList.index(colIndex)
            print >>fo, indent + relName + ".outputIndex[" + str(i) + "] = " + str(outputIndex) + ";"

        for i in range(0, len(newWhereList)):
            colIndex = indexList.index(newWhereList[i].column_name)
            print >>fo, indent + relName + ".whereIndex["+str(i) + "] = " + str(colIndex) + ";"

        if keepInGpu ==0:
            print >>fo, indent + relName + ".KeepInGpu = 0;"
        else:
            print >>fo, indent + relName + ".keepInGpu = 1;"

        print >>fo, indent + relName + ".filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));"
        print >>fo, indent + "CHECK_POINTER(" + relName + ".filter);"

        print >>fo, indent + "(" + relName + ".filter)->nested = 0;"
        print >>fo, indent + "(" + relName + ".filter)->expNum = " + str(len(whereList)) + ";"
        print >>fo, indent + "(" + relName + ".filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *" + str(len(whereList)) + ");"
        print >>fo, indent + "CHECK_POINTER((" + relName + ".filter)->exp);"

        if tn.where_condition.where_condition_exp.func_name in ["AND","OR"]:
            print >>fo, indent + "(" + relName + ".filter)->andOr = " + tn.where_condition.where_condition_exp.func_name + ";"
        else:
            print >>fo, indent + "(" + relName + ".filter)->andOr = EXP;"

        for i in range(0, len(whereList)):
            colIndex = -1
            for j in range(0, len(newWhereList)):
                if newWhereList[j].compare(whereList[i]) is True:
                    colIndex = j
                    break

            if colIndex < 0:
                print 1/0

            colType = whereList[i].column_type
            ctype = to_ctype(colType)

            print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].index    = " + str(colIndex) + ";"

            if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + "_VEC;"
            elif relList[i] == "IN" and isinstance(conList[i], basestring):# in ("MOROCCO")
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = EQ;"
            else:
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].relation = " + relList[i] + ";"
            print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].dataPos  = MEM;"

            # Get subquery result here
            if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                indexDict = {}
                for j in range(0, len(indexList)):
                    indexDict[ tn.table_name + "." + str(indexList[j])] = j
                generate_code_for_a_subquery(fo, lvl, relList[i], conList[i], "header.tupleNum", tnName, indexDict, tn, "MEM")

            if isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "SUBQ":
                print >>fo, indent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &" + var_subqRes + ", sizeof(void *));"
            elif isinstance(conList[i], ystree.YFuncExp) and conList[i].func_name == "LIST":
                vec_len = len(conList[i].parameter_list)
                vec_item_len = type_length(whereList[i].table_name, whereList[i].column_name, whereList[i].column_type)
                print >>fo, indent + "(" + relName + ".filter)->exp[" + str(i) + "].vlen  = " + str(vec_len) + ";"
                print >>fo, indent + "{"
                print >>fo, indent + baseIndent + "char *vec = (char *)malloc(" + vec_item_len + " * " + str(vec_len) + ");"
                print >>fo, indent + baseIndent + "memset(vec, 0, " + vec_item_len + " * " + str(vec_len) + ");"
                for idx in range(0, vec_len):
                    item = conList[i].parameter_list[idx]
                    print >>fo, indent + baseIndent + "memcpy(vec + " + vec_item_len + " * " + str(idx) + ", " + item.cons_value + ", " + vec_item_len +");"
                print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &vec, sizeof(char **));"
                print >>fo, indent + "}"
            elif ctype == "INT":
                if isinstance(conList[i], ystree.YRawColExp):
                    con_value = "*(int *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                else:
                    con_value = conList[i]
                print >>fo, indent + "{"
                print >>fo, indent + baseIndent + "int tmp = " + con_value + ";"
                print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp, sizeof(int));"
                print >>fo, indent + "}"
            elif ctype == "FLOAT":
                if isinstance(conList[i], ystree.YRawColExp):
                    con_value = "*(float *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                else:
                    con_value = conList[i]
                print >>fo, indent + "{"
                print >>fo, indent + baseIndent + "float tmp = " + con_value + ";"
                print >>fo, indent + baseIndent + "memcpy((" + relName + ".filter)->exp[" + str(i) + "].content, &tmp, sizeof(float));"
                print >>fo, indent + "}"
            else:
                if isinstance(conList[i], ystree.YRawColExp):
                    con_value = "_" + conList[i].table_name + "_" + str(conList[i].column_name)
                else:
                    con_value = conList[i]
                print >>fo, indent + "strcpy((" + relName + ".filter)->exp[" + str(i) + "].content, " + con_value + ");\n"

        if CODETYPE == 0:
            print >>fo, indent + "struct tableNode *tmp = tableScan(&" + relName + ", &pp);"
        else:
            print >>fo, indent + "struct tableNode *tmp = tableScan(&" + relName + ", &context, &pp);"

        print >>fo, indent + "if(blockTotal != 1){"

        if CODETYPE == 0:
            print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + ", tmp, &pp);"
        else:
            print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + ", tmp, &context, &pp);"

        print >>fo, indent + "}else{"
        print >>fo, indent + baseIndent + "free(" + resName + ");"
        print >>fo, indent + baseIndent + resName + " = tmp;"
        print >>fo, indent + "}"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
        print >>fo, indent + "freeScan(&" + relName + ");\n"
        if CODETYPE == 1:
            print >>fo, indent + "clFinish(context.queue);"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
        print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"

        ############## end of wherecondition not none

    else:

        print >>fo, indent + "if(blockTotal != 1){"

        if CODETYPE == 0:
            print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + "," + tnName +", &pp);"
        else:
            print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + "," + tnName +", &context, &pp);"

        print >>fo, indent + baseIndent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
        print >>fo, indent + baseIndent + "freeTable(" + tnName + ");"
        if CODETYPE == 1:
            print >>fo, indent + baseIndent + "clFinish(context.queue);"

        print >>fo, indent + baseIndent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
        print >>fo, indent + baseIndent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
        print >>fo, indent + "}else{"
        print >>fo, indent + baseIndent + "free(" + resName + ");"
        print >>fo, indent + baseIndent + resName + " = " + tnName + ";"
        print >>fo, indent + "}"

    print >>fo, indent + "tupleOffset += header.tupleNum;"

    # Generate indexing code
    if tn.indexCols is not None:

        #Init index
        print >>fo, indent + "// Indexing initialization"
        print >>fo, indent + resName + "->colIdxNum = " + str(len(tn.indexCols)) + ";"
        print >>fo, indent + resName + "->colIdx = (int *)malloc(sizeof(int) * " + str(len(tn.indexCols)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + resName + "->colIdx);"
        print >>fo, indent + resName + "->posIdx = (int **)malloc(sizeof(int *) * " + str(len(tn.indexCols)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + resName + "->posIdx);"
        print >>fo, indent + resName + "->contentIdx = (int **)malloc(sizeof(int *) * " + str(len(tn.indexCols)) + ");"
        print >>fo, indent + "CHECK_POINTER(" + resName + "->contentIdx);\n"
 
        # Create index
        countIdxCol = 0
        countCol = 0
        for idxCol in tn.indexCols: 
            for i in range(0, totalAttr): #Columns are NOT scanned in order...need to check which one we need!
                col = colList[i]

                if col.column_name == idxCol.column_name and col.column_type == idxCol.column_type:
                    
                    # Add Index column (countCol needs to be the column pos which is equal to the pos in the table not (and not the index column) )
                    print >>fo, indent + "// Create index for column " + str(col.column_name) + ", type: " + idxCol.column_type
                    print >>fo, indent + resName + "->colIdx["+str(countIdxCol)+"] = "+str(countCol)+";"
                    print >>fo, indent + "createIndex("+resName+","+str(countCol)+","+str(idxCol.column_name)+",&pp);\n"
                    countIdxCol = countIdxCol + 1
                
                    # Add scan indexing
                    if tn.indexScan is not None:
                        whereList = []
                        relList = []
                        conList = []
                        get_where_attr(tn.indexScan.where_condition_exp, whereList, relList, conList)

                        newWhereList = []
                        whereLen = count_whereList(whereList, newWhereList)

                        for i in range(0, len(whereList)):
                            colIndex = -1
                            for j in range(0, len(newWhereList)):
                                if newWhereList[j].compare(whereList[i]) is True:
                                    colIndex = j
                                    break

                            if colIndex < 0:
                                print 1/0

                        colType = whereList[i].column_type
                        ctype = to_ctype(colType)

                        #Get value from the outer table
                        if ctype == "INT":
                            if isinstance(conList[i], ystree.YRawColExp):
                                con_value = "*(int *)(_" + conList[i].table_name + "_" + str(conList[i].column_name) + ")"
                            else:
                                con_value = conList[i]
                        else: 
                            print "[ERROR] - We do not support indexing with complex nesting"
                            print 1/0

                        #Perform indexScan and replace current tableNode with scan result
                        print >>fo, indent + "// Index scan for condition :"+tn.indexScan.where_condition_exp.evaluate() 
                        print >>fo, indent + "int tmpExternalVal = " + con_value + ";"         
                        print >>fo, indent + "struct tableNode *indexScanNode = indexScan("+resName+","+str(countCol)+","+str(idxCol.column_name)+",tmpExternalVal,&pp);"
                        #print >>fo, indent + "free("+resName+");\n"
                        print >>fo, indent + resName+" = indexScanNode;\n"

                #Move to next col
                countCol = countCol + 1

    else:
        print >>fo, indent + "// No Indexing initialization. This query plan does not use indexing!"
        print >>fo, indent + resName + "->colIdxNum = 0;\n"


    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}"
    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}\n"

    return resName

def __traverse_tree(node, func):
    if isinstance(node, ystree.TwoJoinNode):
        __traverse_tree(node.left_child, func)
        __traverse_tree(node.right_child, func)
    elif isinstance(node, ystree.GroupByNode) or isinstance(node, ystree.OrderByNode) or isinstance(node, ystree.SelectProjectNode):
        __traverse_tree(node.child, func)

    func(node)

def generate_code_for_loading_tables(fo, indent, tree):
    global loaded_table_list
    
    # check if a TableNode has new column to load
    def __gen_col_lists(tn, col_lists):
        if not isinstance(tn, ystree.TableNode):
            return

        indexList = []
        colList = []
        generate_col_list(tn, indexList, colList)

        if tn.table_name in col_lists:
            oldList = col_lists[tn.table_name]
            oldIndexList, oldColList = unmerge(oldList)
            for i in range(0, len(indexList)):
                if indexList[i] not in oldIndexList:
                    oldIndexList.append(indexList[i])
                    oldColList.append(colList[i])

            indexList = oldIndexList
            colList = oldColList
        
        col_lists[tn.table_name] = merge(indexList, colList)

    def generate_col_lists(col_lists):
        return lambda tn: __gen_col_lists(tn, col_lists)

    __traverse_tree(tree, generate_col_lists(loaded_table_list))
    map( lambda t: __traverse_tree(t, generate_col_lists(loaded_table_list)), ystree.subqueries )

    for t_name, c_list in loaded_table_list.items():
        generate_code_for_loading_a_table(fo, indent, t_name, c_list)


def generate_code_for_loading_a_table(fo, indent, t_name, c_list):

    tnName  = "_" + t_name.lower() + "_table"
    resName = t_name.lower() + "Table"

    indexList, colList = unmerge(c_list)

    print >>fo, indent + "// Load columns from the table " + t_name

    print >>fo, indent + "struct tableNode *" + resName + ";"
    print >>fo, indent + resName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
    print >>fo, indent + "CHECK_POINTER("+ resName + ");"
    print >>fo, indent + "initTable(" + resName + ");"

    print >>fo, indent + "{"
    indent += baseIndent
    print >>fo, indent + "struct tableNode *" + tnName + ";"
    print >>fo, indent + "int outFd;"
    print >>fo, indent + "long outSize;"
    print >>fo, indent + "char *outTable;"
    print >>fo, indent + "long offset, tupleOffset;"
    print >>fo, indent + "int blockTotal;"
    print >>fo, indent + "struct columnHeader header;\n"

    totalAttr = len(indexList)
    if totalAttr <= 0:
        print "ERROR: Failed to generate code for loading the table " + t_name + ": no column is specified"
        exit(-1)

    firstTableFile = t_name + str(colList[0].column_name)
    print >>fo, indent + "// Retrieve the block number from " + firstTableFile
    print >>fo, indent + "outFd = open(\"" + firstTableFile + "\", O_RDONLY);"
    print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
    print >>fo, indent + "blockTotal = header.blockTotal;"
    print >>fo, indent + "close(outFd);"
    print >>fo, indent + "offset = 0;"
    print >>fo, indent + "tupleOffset = 0;"

    print >>fo, indent + "for(int i = 0; i < blockTotal; i++){\n"
    indent += baseIndent
    print >>fo, indent + "// Table initialization"
    print >>fo, indent + tnName + " = (struct tableNode *)malloc(sizeof(struct tableNode));"
    print >>fo, indent + "CHECK_POINTER(" + tnName + ");"
    print >>fo, indent + tnName + "->totalAttr = " + str(totalAttr) + ";"
    print >>fo, indent + tnName + "->attrType = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrType);"
    print >>fo, indent + tnName + "->attrSize = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrSize);"
    print >>fo, indent + tnName + "->attrIndex = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrIndex);"
    print >>fo, indent + tnName + "->attrTotalSize = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->attrTotalSize);"
    print >>fo, indent + tnName + "->dataPos = (int *)malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataPos);"
    print >>fo, indent + tnName + "->dataFormat = (int *) malloc(sizeof(int) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->dataFormat);"
    print >>fo, indent + tnName + "->content = (char **)malloc(sizeof(char *) * " + str(totalAttr) + ");"
    print >>fo, indent + "CHECK_POINTER(" + tnName + "->content);\n"

    tupleSize = "0"
    for i in range(0, totalAttr):
        col = colList[i]
        ctype = to_ctype(col.column_type)
        colIndex = int(col.column_name)
        colLen = type_length(t_name, colIndex, col.column_type)
        tupleSize += " + " + colLen

        print >>fo, indent + "// Load column " + str(colIndex) + ", type: " + col.column_type
        print >>fo, indent + tnName + "->attrSize[" + str(i) + "] = " + colLen + ";"
        print >>fo, indent + tnName + "->attrIndex["+ str(i) + "] = " + str(colIndex) + ";"
        print >>fo, indent + tnName + "->attrType[" + str(i) + "] = " + ctype + ";"

        if POS == 0:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"
        elif POS == 1:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = PINNED;"
        elif POS == 2:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = UVA;"
        elif POS == 3:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MMAP;"
        else:
            print >>fo, indent + tnName + "->dataPos[" + str(i) + "] = MEM;"

        print >>fo, indent + "outFd = open(\"" + t_name + str(colIndex) + "\", O_RDONLY);"
        print >>fo, indent + "offset = i * sizeof(struct columnHeader) + tupleOffset * " + str(colLen) + ";"
        print >>fo, indent + "lseek(outFd, offset, SEEK_SET);"
        print >>fo, indent + "read(outFd, &header, sizeof(struct columnHeader));"
        print >>fo, indent + "offset += sizeof(struct columnHeader);"
        print >>fo, indent + tnName + "->dataFormat[" + str(i) + "] = header.format;"
        print >>fo, indent + "outSize = header.tupleNum * " + colLen + ";"
        print >>fo, indent + tnName + "->attrTotalSize[" + str(i) + "] = outSize;\n"

        print >>fo, indent + "clock_gettime(CLOCK_REALTIME,&diskStart);"
        print >>fo, indent + "outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"

        if CODETYPE == 0:
            if POS == 1:
                print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName + "->content[" + str(i) + "], outSize));"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 2:
                print >>fo, indent + "CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&" + tnName+"->content["+str(i)+"], outSize));"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 3:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
            else:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
        else:
            if POS == 0:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)memalign(256, outSize);"
                    print >>fo, indent + "memcpy(" + tnName + "->content[" + str(i) + "], outTable, outSize);"
            elif POS == 3:
                    print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);"
            else:
                print >>fo, indent + tnName + "->content[" + str(i) + "] = (char *)clCreateBuffer(context.context, CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR, outSize, NULL, 0);"
                print >>fo, indent + "clTmp = clEnqueueMapBuffer(context.queue, (cl_mem)" + tnName + "->content[" + str(i) + "], CL_TRUE,CL_MAP_WRITE,0,outSize, 0, 0, 0, 0);"
                print >>fo, indent + "memcpy(clTmp, outTable, outSize);"
                print >>fo, indent + "clEnqueueUnmapMemObject(context.queue, (cl_mem)" + tnName + "->content[" + str(i) + "], clTmp, 0, 0, 0);"

        print >>fo, indent + "munmap(outTable, outSize);"
        print >>fo, indent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
        print >>fo, indent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
        print >>fo, indent + "close(outFd);\n"

    print >>fo, indent + tnName + "->tupleSize = " + tupleSize + ";"
    print >>fo, indent + tnName + "->tupleNum = header.tupleNum;\n"

    print >>fo, indent + "if(blockTotal != 1){"

    if CODETYPE == 0:
        print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + "," + tnName +", &pp);"
    else:
        print >>fo, indent + baseIndent + "mergeIntoTable(" + resName + "," + tnName +", &context, &pp);"

    print >>fo, indent + baseIndent + "clock_gettime(CLOCK_REALTIME, &diskStart);"
    print >>fo, indent + baseIndent + "freeTable(" + tnName + ");"
    if CODETYPE == 1:
        print >>fo, indent + baseIndent + "clFinish(context.queue);"

    print >>fo, indent + baseIndent + "clock_gettime(CLOCK_REALTIME, &diskEnd);"
    print >>fo, indent + baseIndent + "diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;"
    print >>fo, indent + "}else{"
    print >>fo, indent + baseIndent + "free(" + resName + ");"
    print >>fo, indent + baseIndent + resName + " = " + tnName + ";"
    print >>fo, indent + "}"

    print >>fo, indent + "tupleOffset += header.tupleNum;"

    print >>fo, indent + resName + "->colIdxNum = 0;"

    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}"
    indent = indent[:indent.rfind(baseIndent)]
    print >>fo, indent + "}\n"

    return resName

    # Generate indexing code
    # if tn.indexCols is not None:

    #     #Init index
    #     print >>fo, indent + "// Indexing initialization"
    #     print >>fo, indent + resName + "->colIdxNum = " + str(len(tn.indexCols)) + ";"
    #     print >>fo, indent + resName + "->colIdx = (int *)malloc(sizeof(int) * " + str(len(tn.indexCols)) + ");"
    #     print >>fo, indent + "CHECK_POINTER(" + resName + "->colIdx);"
    #     print >>fo, indent + resName + "->contentIdx = (char **)malloc(sizeof(char *) * " + str(len(tn.indexCols)) + ");"
    #     print >>fo, indent + "CHECK_POINTER(" + resName + "->contentIdx);"
    #     print >>fo, indent + resName + "->posIdx = (int **)malloc(sizeof(int *) * " + str(len(tn.indexCols)) + ");"
    #     print >>fo, indent + "CHECK_POINTER(" + resName + "->posIdx);\n"
    #     count = 0

    #     # Create index
    #     for idxCol in tn.indexCols:
    #         print >>fo, indent + "// Create index for column " + str(idxCol.column_name) + ", type: " + idxCol.column_type
    #         print >>fo, indent + resName + "->colIdx["+str(count)+"] = "+str(idxCol.column_name)+";"
    #         print >>fo, indent + "createIndex("+resName+","+str(count)+","+str(idxCol.column_name)+",&pp);\n"
    #         count = count + 1

    #     # Add scan indexing
    #     if tn.indexScan is not None:
    #         whereList = []
    #         relList = []
    #         conList = []
    #         get_where_attr(tn.indexScan.where_condition_exp, whereList, relList, conList)

    #         if len(relList) != 1:
    #             print "[ERROR] : Cannot use complicated nested condition with indexing!"
    #             exit(-1)
    #         if relList[0] != "EQ":
    #             print "[ERROR] : Can only use \"EQ\" nested condition with indexing!"
    #             exit(-1)

    #         #Part outer
    #         for col in whereList:
    #             print col.table_name
    #             print col.column_name

    #         #TODO need to fix that to pass the outer table
    #         print >>fo, indent + "// Index scan for condition :"+tn.indexScan.where_condition_exp.evaluate()
    #         print >>fo, indent + "// createIndex("+resName+",&"+var_subqRes+","+str(conList[0].column_name)+",&pp);\n"

    # else:
    #     print >>fo, indent + "// No Indexing initialization. This query plan does not use indexing!"
    #     print >>fo, indent + resName + "->colIdxNum = 0;\n"


